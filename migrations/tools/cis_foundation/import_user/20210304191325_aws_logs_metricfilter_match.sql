-- migrate:up
CREATE OR REPLACE FUNCTION aws_logs_metricfilter_pattern_matches(target text, example text)
  RETURNS BOOLEAN AS $$/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
(function(root) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { Expression: peg$parseExpression },
        peg$startRuleFunction  = peg$parseExpression,

        peg$c0 = "{",
        peg$c1 = peg$literalExpectation("{", false),
        peg$c2 = "}",
        peg$c3 = peg$literalExpectation("}", false),
        peg$c4 = function(filter) { return filter; },
        peg$c5 = "&&",
        peg$c6 = peg$literalExpectation("&&", false),
        peg$c7 = "||",
        peg$c8 = peg$literalExpectation("||", false),
        peg$c9 = function(head, tail) {
            return tail.reduce((result, el) => {
              const op = el[1];
              const item = el[3];

              if (op == '||') {
                return {
                  op,
                  l: result,
                  r: item
                };
              } else {
                // need to find rightmost term and replace
                var prev = null;
                var cur = result;
                while ('r' in cur && !('group' in cur)) {
                  prev = cur;
                  cur = cur.r;
                }
                if (prev === null) {
                  return {
                    op,
                    l: result,
                    r: item
                  }
                } else {
                  prev.l = {
                    op: prev.op,
                    l: prev.l,
                    r: cur
                  }
                  prev.op = op,
                  prev.r = item
                  return result;
                }
              }



            }, head);
          },
        peg$c10 = function(term) { return term; },
        peg$c11 = "(",
        peg$c12 = peg$literalExpectation("(", false),
        peg$c13 = ")",
        peg$c14 = peg$literalExpectation(")", false),
        peg$c15 = function(filter) {
            filter['group'] = true;
            return filter;
          },
        peg$c16 = function(selector, op, match) { return {selector, op, match}; },
        peg$c17 = "NOT EXISTS",
        peg$c18 = peg$literalExpectation("NOT EXISTS", false),
        peg$c19 = function(selector) { return {selector, op: 'not exists', match: ''}},
        peg$c20 = "$",
        peg$c21 = peg$literalExpectation("$", false),
        peg$c22 = function() { return text(); },
        peg$c23 = ".",
        peg$c24 = peg$literalExpectation(".", false),
        peg$c25 = /^[a-zA-Z\-_]/,
        peg$c26 = peg$classExpectation([["a", "z"], ["A", "Z"], "-", "_"], false, false),
        peg$c27 = "[",
        peg$c28 = peg$literalExpectation("[", false),
        peg$c29 = /^[0-9]/,
        peg$c30 = peg$classExpectation([["0", "9"]], false, false),
        peg$c31 = "]",
        peg$c32 = peg$literalExpectation("]", false),
        peg$c33 = "=",
        peg$c34 = peg$literalExpectation("=", false),
        peg$c35 = "!=",
        peg$c36 = peg$literalExpectation("!=", false),
        peg$c37 = /^[.*a-zA-Z0-9]/,
        peg$c38 = peg$classExpectation([".", "*", ["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
        peg$c39 = function(chars) { return chars.join(''); },
        peg$c40 = "\"",
        peg$c41 = peg$literalExpectation("\"", false),
        peg$c42 = /^[.*a-zA-Z0-9@$\\ ]/,
        peg$c43 = peg$classExpectation([".", "*", ["a", "z"], ["A", "Z"], ["0", "9"], "@", "$", "\\", " "], false, false),
        peg$c44 = function(quoted) { return quoted.join(''); },
        peg$c45 = peg$otherExpectation("whitespace"),
        peg$c46 = /^[ \t\n\r]/,
        peg$c47 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c0;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseFilter();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c2;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c3); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFilter() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseTermSequence();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c5) {
            s5 = peg$c5;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s5 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c7) {
              s5 = peg$c7;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseTermSequence();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c5) {
              s5 = peg$c5;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c6); }
            }
            if (s5 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c7) {
                s5 = peg$c7;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c8); }
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseTermSequence();
                if (s7 !== peg$FAILED) {
                  s4 = [s4, s5, s6, s7];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c9(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseTermSequence() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseTerm();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c10(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c11;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseFilter();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s5 = peg$c13;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c14); }
                }
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c15(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseTerm() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseSelector();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOp();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMatch();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseSelector();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 10) === peg$c17) {
              s3 = peg$c17;
              peg$currPos += 10;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c19(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseSelector() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c20;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseJsonPath();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c22();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseJsonPath() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsePathSegment();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsePathSegment();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsePathSegment();
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePathSegment() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c23;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c24); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c25.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c25.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c26); }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c29.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c30); }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c29.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c30); }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s3 = peg$c31;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c32); }
            }
            if (s3 !== peg$FAILED) {
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseOp() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 61) {
        s0 = peg$c33;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c35) {
          s0 = peg$c35;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
      }

      return s0;
    }

    function peg$parseMatch() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c37.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c38); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c37.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c40;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          if (peg$c42.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c42.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c43); }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c40;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c41); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c46.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c46.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c47); }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  root.peg = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
})(this);
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
// const { Variable, Binary } = require('./expr.js');
var exports = (function () {
    var id = 0;
    function toHexUnsignednopf(x) {
        x = (x | 0) + 0xFFFFFFFF + 1;
        var s = x.toString(16);
        return ("00000000" + s).substr(-8);
    }
    // START - BigInt
    function BigInt(x) {
        if (x < 0)
            throw "BigInt must be non-negative";
        this.data = [x | 0];
    }
    BigInt.prototype.shl = function (n) {
        "use strict";
        var newdata = this.data.slice(0);
        while (n >= 32) {
            n -= 32;
            newdata.unshift(0);
        }
        if (n != 0) {
            var leftover = 0;
            for (var i = 0; i < newdata.length; i++) {
                var carry = newdata[i] >>> (32 - n);
                newdata[i] = (newdata[i] << n) | leftover;
                leftover = carry;
            }
            if (leftover != 0)
                newdata.push(leftover);
        }
        var res = new BigInt(0);
        res.data = newdata;
        return res;
    };
    BigInt.prototype.add = function (a) {
        "use strict";
        var newdata = [];
        var carry = 0;
        for (var i = 0; i < Math.max(this.data.length, a.data.length); i++) {
            var x = i < this.data.length ? this.data[i] : 0;
            var y = i < a.data.length ? a.data[i] : 0;
            var z = (x >>> 0) + (y >>> 0) + carry;
            if (z >= 4294967296)
                carry = 1;
            else
                carry = 0;
            newdata[i] = z | 0;
        }
        if (carry != 0)
            newdata.push(1);
        var res = new BigInt(0);
        res.data = newdata;
        return res;
    };
    BigInt.prototype.toString = function () {
        if (this.data.length == 1 && this.data[0] >= 0 && this.data[0] <= 65536) {
            return this.data[0] + "";
        }
        var parts = this.data.slice(0);
        parts.reverse();
        return "0x" + parts.map(toHexUnsignednopf).join('_');
    };
    // END - BigInt
    // START - expr
    function Node() {
        this.hash = 0;
        this.hash2 = 0;
        this.weight = 0;
        this.type = 'Node';
        this.id = id++;
    }
    // structural equality with commutivity
    Node.prototype.equals = function (node) {
        alert("This object should not exist");
        return false;
    };
    // structural equality without commutivity
    Node.prototype.equals2 = function (node) {
        alert("This object should not exist");
        return false;
    };
    Node.prototype.print = function (varmap) {
        alert("This object should not exist");
        return "this should never exist";
    };
    Node.prototype.toBddFunc = function () {
        alert("This object should not exist");
        return null;
    };
    Node.prototype.toCircuitFunc = function () {
        alert("This object should not exist");
        return null;
    };
    Node.prototype.toSSECircuitFunc = function () {
        alert("This object should not exist");
        return null;
    };
    Node.prototype.removeDummy = function () {
        return this;
    };
    Node.prototype.constantFold = function () {
        return this;
    };
    Node.prototype.containsDoubleUnary = function () {
        return 0;
    };
    Node.prototype.copy = function () {
        alert("This object should not exist");
        return null;
    };
    Node.prototype.eval = function (vars) {
        alert("This object should not exist");
        return null;
    };
    Node.prototype.sseeval = function (vars) {
        alert("This object should not exist");
        return null;
    };
    function Constant(val) {
        Node.call(this);
        this.hash = val | 0;
        this.hash2 = (val & 15) | ((val >>> 31) << 4);
        this.value = val | 0;
        this.type = 'const';
    }
    Constant.prototype = Object.create(Node.prototype);
    Constant.prototype.constructor = Constant;
    Constant.prototype.equals = function (node) {
        return node.type == 'const' && node.value == this.value;
    };
    Constant.prototype.equals2 = function (node) {
        return node.type == 'const' && node.value == this.value;
    };
    Constant.prototype.print = function (varmap) {
        return formatConstant(this.value);
    };
    Constant.prototype.toBddFunc = function () {
        return BDDFunction.constant(this.value);
    };
    Constant.prototype.toCircuitFunc = function () {
        return CFunction.constant(this.value);
    };
    Constant.prototype.toSSECircuitFunc = function () {
        return this.value;
    };
    Constant.prototype.copy = function () {
        return new Constant(this.value);
    };
    Constant.prototype.eval = function (vars) {
        return this.value;
    };
    Constant.prototype.sseeval = function (vars) {
        return this.value;
    };
    function Variable(index) {
        Node.call(this);
        this.hash = index * 31;
        this.hash2 = 0;
        this.index = index;
        this.type = 'var';
    }
    Variable.prototype = Object.create(Node.prototype);
    Variable.prototype.constructor = Variable;
    Variable.prototype.equals = function (node) {
        return node.type == 'var' && node.index == this.index;
    };
    Variable.prototype.equals2 = function (node) {
        return node.type == 'var' && node.index == this.index;
    };
    Variable.prototype.print = function (varmap) {
        return varmap[this.index];
    };
    Variable.prototype.toBddFunc = function () {
        return BDDFunction.argument(this.index);
    };
    Variable.prototype.toCircuitFunc = function () {
        return CFunction.argument(this.index);
    };
    Variable.prototype.toSSECircuitFunc = function () {
        return SSECFunction.argument(this.index);
    };
    Variable.prototype.copy = function () {
        return new Variable(this.index);
    };
    Variable.prototype.eval = function (vars) {
        return vars[this.index];
    };
    Variable.prototype.sseeval = function (vars) {
        return vars[this.index];
    };
    function Unary(op, val) {
        Node.call(this);
        //if (op < 0 || val == null || val == undefined) debugger;
        this.hash = (val.hash << 17) - val.hash + op + 1 | 0;
        this.hash2 = (op + 1 & 31) | ((val.hash2 & 31) << 5);
        this.op = op;
        this.value = val;
        this.weight = val.weight;
        if (op == 0)
            this.weight += 1.0;
        else if (op == 1)
            this.weight += 1.1;
        else
            this.weight += 2.0;
        this.type = 'un';
    }
    Unary.prototype = Object.create(Node.prototype);
    Unary.prototype.constructor = Unary;
    Unary.prototype.equals = function (node) {
        return node.type == 'un' && node.op == this.op && node.value.equals(this.value);
    };
    Unary.prototype.equals2 = function (node) {
        return node.type == 'un' && node.op == this.op && node.value.equals2(this.value);
    };
    Unary.prototype.print = function (varmap) {
        if (this.op > 1)
            return unops[this.op].substr(1) + "(" + this.value.print(varmap) + ")";
        var o = unops[this.op];
        if (((this.value.type == 'bin' || this.value.type == 'assoc') && this.value.op < 55) || this.value.type == 'ter')
            return o + "(" + this.value.print(varmap) + ")";
        else
            return o + this.value.print(varmap);
    };
    Unary.prototype.toBddFunc = function () {
        var bddf = unaryToBddFunction(this.op, this.value.toBddFunc());
        this.bddf = bddf;
        return bddf;
    };
    function unaryToBddFunction(op, inner) {
        if (op == "dummy")
            return inner;
        switch (op) {
            case 0: return BDDFunction.not(inner);
            case 1: return BDDFunction.sub(BDDFunction.constant(0), inner);
            case 2: return BDDFunction.popcnt(inner);
            case 3: return BDDFunction.ctz(inner);
            case 4: return BDDFunction.clz(inner);
            case 5: return BDDFunction.rbit(inner);
            case 6: return BDDFunction.abs(inner);
            case 7: return BDDFunction.ez80mlt(inner);
            case 8: return BDDFunction.and(inner, BDDFunction.sub(BDDFunction.constant(0), inner));
            case 9: return BDDFunction.and(inner, BDDFunction.sub(inner, BDDFunction.constant(1)));
            case 10: return BDDFunction.xor(inner, BDDFunction.sub(inner, BDDFunction.constant(1)));
            case 11: return BDDFunction.and(BDDFunction.not(inner), BDDFunction.sub(inner, BDDFunction.constant(1)));
        }
        alert("Severe bug in Unary.toBddFunc");
    }
    Unary.prototype.toCircuitFunc = function () {
        var inner = this.value.toCircuitFunc();
        if (this.op == "dummy")
            return inner;
        switch (this.op) {
            case 0: return CFunction.not(inner);
            case 1: return CFunction.sub(CFunction.constant(0), inner);
            case 2: return CFunction.popcnt(inner);
            case 3: return CFunction.ctz(inner);
            case 4: return CFunction.clz(inner);
            case 5: return CFunction.rbit(inner);
            case 6: return CFunction.abs(inner);
            case 7: return CFunction.ez80mlt(inner);
            case 8: return CFunction.and(inner, CFunction.sub(CFunction.constant(0), inner));
            case 9: return CFunction.and(inner, CFunction.sub(inner, CFunction.constant(1)));
            case 10: return CFunction.xor(inner, CFunction.sub(inner, CFunction.constant(1)));
            case 11: return CFunction.and(CFunction.not(inner), CFunction.sub(inner, CFunction.constant(1)));
        }
        //debugger;
        alert("Severe bug in Unary.toCircuitFunc");
    };
    Unary.prototype.removeDummy = function () {
        var inner = this.value.removeDummy();
        if (this.op == 'dummy')
            return inner;
        if (this.value.id != inner.id)
            return new Unary(this.op, inner);
        return this;
    };
    Unary.prototype.constantFold = function (nrec) {
        var inner = nrec ? this.value : this.value.constantFold(false);
        if (inner.type == 'const') {
            switch (this.op) {
                case "dummy": return this;
                default: throw "invalid unary"; // debugger;
                case 0: return new Constant(~inner.value);
                case 1: return new Constant(-inner.value | 0);
                case 2: return new Constant(popcnt(inner.value));
                case 3: return new Constant(ctz(inner.value));
                case 4: return new Constant(clz(inner.value));
                case 5: return new Constant(rbit(inner.value));
                case 6:
                    var t = inner.value | 0;
                    var m = t >> 31;
                    return new Constant((t ^ m) - m | 0);
                case 7: return new Constant((inner.value & 0xFF) * ((inner.value >> 8) & 0xFF));
                case 8: return new Constant(inner.value & -inner.value);
                case 9: return new Constant(inner.value & inner.value - 1);
                case 10: return new Constant(inner.value ^ inner.value - 1);
                case 11: return new Constant(~inner.value & inner.value - 1);
            }
        }
        if (inner.id != this.value.id)
            return new Unary(this.op, inner);
        return this;
    };
    Unary.prototype.containsDoubleUnary = function () {
        return (this.value.type == 'un' ? 1 : 0) + this.value.containsDoubleUnary();
    };
    Unary.prototype.copy = function () {
        return new Unary(this.op, this.value.copy());
    };
    Unary.prototype.eval = function (vars) {
        var inner = this.value.eval(vars);
        switch (this.op) {
            default: throw "invalid unary"; // debugger;
            case 0: return ~inner;
            case 1: return -inner | 0;
            case 2: return popcnt(inner);
            case 3: return ctz(inner);
            case 4: return clz(inner);
            case 5: return rbit(inner);
            case 6:
                var t = (inner | 0) >> 31;
                return ((inner ^ t) - t) | 0;
            case 7: return (inner & 0xFF) * ((inner >> 8) & 0xFF);
            case 8: return inner & -inner;
            case 9: return inner & inner - 1;
            case 10: return inner ^ inner - 1;
            case 11: return ~inner & inner - 1;
        }
    };
    Unary.prototype.toSSECircuitFunc = function (vars) {
        return this.eval(vars);
    };
    function Binary(op, l, r) {
        Node.call(this);
        //if (op < 0 || l == null || r == null) debugger;
        var lhash = l.hash;
        var rhash = r.hash;
        // if commutative operation, use commutative hash
        if (commutative[op]) {
            var x = lhash ^ rhash;
            lhash = Math.min(lhash, rhash);
            rhash = x ^ lhash;
        }
        this.hash = (((lhash * 31 | 0) + rhash) * 31 | 0) + op * 1009 | 0;
        this.hash2 = (op + 5 & 31) | ((l.hash2 & 31) << 5) | ((r.hash2 & 31) << 10);
        this.op = op;
        this.r = r;
        this.l = l;
        this.type = 'bin';
        var opweight = 1.0;
        if (op >= 4)
            opweight = 1.1;
        if ((op >= 10 && op <= 14) || (op >= 32 && op <= 35))
            opweight = 4.0;
        this.weight = opweight + l.weight + r.weight;
    }
    Binary.prototype = Object.create(Node.prototype);
    Binary.prototype.constructor = Binary;
    Binary.prototype.equals = function (node) {
        if (node.hash != this.hash || node.type != 'bin' || node.op != this.op)
            return false;
        if (!commutative[this.op])
            return node.l.equals(this.l) && node.r.equals(this.r);
        else
            return node.l.equals(this.l) && node.r.equals(this.r) ||
                node.l.equals(this.r) && node.r.equals(this.l);
    };
    Binary.prototype.equals2 = function (node) {
        return node.hash == this.hash && node.type == 'bin' && node.op == this.op && node.l.equals2(this.l) && node.r.equals2(this.r);
    };
    Binary.prototype.print = function (varmap) {
        if (isbinfunc(this.op))
            return ops[this.op].substr(1) + "(" + this.l.print(varmap) + ", " + this.r.print(varmap) + ")";
        var res = "";
        if (this.l.type == 'bin' || this.l.type == 'ter' || this.l.type == 'assoc')
            res += "(" + this.l.print(varmap) + ")";
        else
            res += this.l.print(varmap);
        res += " " + ops[this.op] + " ";
        if (this.r.type == 'bin' || this.r.type == 'ter' || this.r.type == 'assoc')
            res += "(" + this.r.print(varmap) + ")";
        else
            res += this.r.print(varmap);
        return res;
    };
    Binary.prototype.toBddFunc = function () {
        var op = this.op;
        if (((op >= 12 && op <= 14) || (op >= 32 && op <= 35) || (op >= 59)) && this.l.type != 'const' && this.r.type != 'const')
            throw "BDD timeout";
        var bddf = binaryToBddFunc(op, this.l.toBddFunc(), this.r.toBddFunc());
        this.bddf = bddf;
        return bddf;
    };
    function binaryToBddFunc(op, l, r) {
        switch (op) {
            case 1: return BDDFunction.and(l, r);
            case 2: return BDDFunction.or(l, r);
            case 3: return BDDFunction.xor(l, r);
            case 4: return BDDFunction.add(l, r);
            case 5: return BDDFunction.sub(l, r);
            case 6: return BDDFunction.shl(l, r);
            case 8: return BDDFunction.rol(l, r);
            case 9: return BDDFunction.ror(l, r);
            case 11: return BDDFunction.mul(l, r);
            case 12: return BDDFunction.dive(l, r);
            case 13: return BDDFunction.reme(l, r);
            case 14: return BDDFunction.divupony(l, r);
            case 20: return BDDFunction.eq(l, r);
            case 21: return BDDFunction.not(BDDFunction.eq(l, r));
            case 26: return BDDFunction.or(BDDFunction.not(BDDFunction.hor(l)), BDDFunction.hor(r));
            case 27: return BDDFunction.and(BDDFunction.hor(l), BDDFunction.hor(r));
            case 28: return BDDFunction.or(BDDFunction.hor(l), BDDFunction.hor(r));
            case 30: return BDDFunction.shrs(l, r);
            case 31: return BDDFunction.shru(l, r);
            case 22:
            case 41: return BDDFunction.le(l, r, false);
            case 40: return BDDFunction.le(l, r, true);
            case 23:
            case 43: return BDDFunction.lt(l, r, false);
            case 42: return BDDFunction.lt(l, r, true);
            case 24:
            case 45: return BDDFunction.ge(l, r, false);
            case 44: return BDDFunction.ge(l, r, true);
            case 25:
            case 47: return BDDFunction.gt(l, r, false);
            case 46: return BDDFunction.gt(l, r, true);
            case 48: return BDDFunction.bzhi(l, r);
            case 49: return BDDFunction.subus(l, r);
            case 50: return BDDFunction.pdep(l, r);
            case 51: return BDDFunction.pext(l, r);
            case 52: return BDDFunction.avg_up(l, r);
            case 53: return BDDFunction.not(BDDFunction.subus(BDDFunction.not(l), r));
            case 55: return BDDFunction.mux(BDDFunction.gt(l, r, false), l, r);
            case 56: return BDDFunction.mux(BDDFunction.gt(l, r, true), l, r);
            case 57: return BDDFunction.mux(BDDFunction.lt(l, r, false), l, r);
            case 58: return BDDFunction.mux(BDDFunction.lt(l, r, true), l, r);
            case 32: return BDDFunction.divs(l, r);
            case 33: return BDDFunction.divu(l, r);
            case 34: return BDDFunction.rems(l, r);
            case 35: return BDDFunction.remu(l, r);
            case 59: return BDDFunction.hmul(l, r, false);
            case 60: return BDDFunction.hmul(l, r, true);
            case 61: return BDDFunction.clmul(l, r);
            case 62: return BDDFunction.clpow(l, r);
            case 63: return BDDFunction.ormul(l, r);
            default: alert("Unimplemented operation in binaryToBddFunc");
        }
    }
    Binary.prototype.toCircuitFunc = function () {
        return binaryToCircuitFunc(this.op, this.l.toCircuitFunc(), this.r.toCircuitFunc());
    };
    function binaryToCircuitFunc(op, l, r) {
        switch (op) {
            case 1: return CFunction.and(l, r);
            case 2: return CFunction.or(l, r);
            case 3: return CFunction.xor(l, r);
            case 4: return CFunction.add(l, r);
            case 5: return CFunction.sub(l, r);
            case 6: return CFunction.shl(l, r);
            case 8: return CFunction.rol(l, r);
            case 9: return CFunction.ror(l, r);
            case 11: return CFunction.mul(l, r);
            case 12: return CFunction.dive(l, r);
            case 13: return CFunction.reme(l, r);
            case 14: return CFunction.divupony(l, r);
            case 20: return CFunction.eq(l, r);
            case 21: return CFunction.not(CFunction.eq(l, r));
            case 26: return CFunction.or(CFunction.not(CFunction.hor(l)), CFunction.hor(r));
            case 27: return CFunction.and(CFunction.hor(l), CFunction.hor(r));
            case 28: return CFunction.or(CFunction.hor(l), CFunction.hor(r));
            case 30: return CFunction.shrs(l, r);
            case 31: return CFunction.shru(l, r);
            case 22:
            case 41: return CFunction.le(l, r, false);
            case 40: return CFunction.le(l, r, true);
            case 23:
            case 43: return CFunction.lt(l, r, false);
            case 42: return CFunction.lt(l, r, true);
            case 24:
            case 45: return CFunction.ge(l, r, false);
            case 44: return CFunction.ge(l, r, true);
            case 25:
            case 47: return CFunction.gt(l, r, false);
            case 46: return CFunction.gt(l, r, true);
            case 48: return CFunction.bzhi(l, r);
            case 49: return CFunction.subus(l, r);
            case 50: return CFunction.pdep(l, r);
            case 51: return CFunction.pext(l, r);
            case 52: return CFunction.avg_up(l, r);
            case 53: return CFunction.not(CFunction.subus(CFunction.not(l), r));
            case 55: return CFunction.mux(CFunction.gt(l, r, false), l, r);
            case 56: return CFunction.mux(CFunction.gt(l, r, true), l, r);
            case 57: return CFunction.mux(CFunction.lt(l, r, false), l, r);
            case 58: return CFunction.mux(CFunction.lt(l, r, true), l, r);
            case 32: return CFunction.divs(l, r);
            case 33: return CFunction.divu(l, r);
            case 34: return CFunction.rems(l, r);
            case 35: return CFunction.remu(l, r);
            case 59: return CFunction.hmul(l, r, false);
            case 60: return CFunction.hmul(l, r, true);
            case 61: return CFunction.clmul(l, r);
            case 62: return CFunction.clpow(l, r);
            case 63: return CFunction.ormul(l, r);
        }
        alert("Unimplemented operation in binaryToCircuitFunc");
    }
    Binary.prototype.removeDummy = function () {
        var l = this.l.removeDummy();
        var r = this.r.removeDummy();
        if (this.l.id != l.id ||
            this.r.id != r.id)
            return new Binary(this.op, l, r);
        return this;
    };
    Binary.prototype.constantFold = function (nrec) {
        var l = nrec ? this.l : this.l.constantFold(false);
        var r = nrec ? this.r : this.r.constantFold(false);
        if (l.type == 'const' && r.type == 'const' && !mayThrow(this.op)) {
            return new Constant(this.eval(null));
        }
        if (l.id != this.l.id ||
            r.id != this.r.id)
            return new Binary(this.op, l, r);
        return this;
    };
    Binary.prototype.containsDoubleUnary = function () {
        return this.l.containsDoubleUnary() + this.r.containsDoubleUnary();
    };
    Binary.prototype.copy = function () {
        return new Binary(this.op, this.l.copy(), this.r.copy());
    };
    function evalBinary(op, l, r) {
        var m = 0x80000000;
        switch (op) {
            default: throw "Unimplemented operation in evalBinary";
            case 1: return l & r;
            case 2: return l | r;
            case 3: return l ^ r;
            case 4: return l + r | 0;
            case 5: return l - r | 0;
            case 6: return l << (r & 31);
            case 8: return (l << (r & 31)) | (l >>> (-r & 31));
            case 9: return (l >>> (r & 31)) | (l << (-r & 31));
            case 7:
            case 31: return (l >>> (r & 31)) | 0;
            case 30: return l >> (r & 31);
            case 8: return (l << (r & 31)) | (l >>> (-r & 31));
            case 9: return (l >>> (r & 31)) | (l << (-r & 31));
            case 12: return BDDFunction.to_constant(BDDFunction.dive(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 13: return BDDFunction.to_constant(BDDFunction.reme(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 14: return BDDFunction.to_constant(BDDFunction.divupony(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 10:
            case 33: return BDDFunction.to_constant(BDDFunction.divu(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 32: return BDDFunction.to_constant(BDDFunction.divs(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 34: return BDDFunction.to_constant(BDDFunction.rems(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 35: return BDDFunction.to_constant(BDDFunction.remu(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 11: return Math.imul(l, r);
            case 20: return l == r ? -1 : 0;
            case 21: return l != r ? -1 : 0;
            case 41:
            case 22: return (l ^ m) <= (r ^ m) ? -1 : 0;
            case 43:
            case 23: return (l ^ m) < (r ^ m) ? -1 : 0;
            case 45:
            case 24: return (l ^ m) >= (r ^ m) ? -1 : 0;
            case 47:
            case 25: return (l ^ m) > (r ^ m) ? -1 : 0;
            case 26: return (l == 0 || r != 0) ? -1 : 0;
            case 27: return (l != 0 && r != 0) ? -1 : 0;
            case 28: return (l != 0 || r != 0) ? -1 : 0;
            case 40: return l <= r ? -1 : 0;
            case 42: return l < r ? -1 : 0;
            case 44: return l >= r ? -1 : 0;
            case 46: return l > r ? -1 : 0;
            case 48: return ((r & 0xFF) >= 31 ? l : l & (1 << r) - 1) | 0;
            case 49: return (l >>> 0) < (r >>> 0) ? 0 : (l - r) | 0;
            case 50: return BDDFunction.to_constant(BDDFunction.pdep(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 51: return BDDFunction.to_constant(BDDFunction.pext(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 52: return BDDFunction.to_constant(BDDFunction.avg_up(BDDFunction.constant(l), BDDFunction.constant(r)));
            case 53: return Math.min((l >>> 0) + (r >>> 0), 0xFFFFFFFF) | 0;
            case 55: return Math.min(l ^ m, r ^ m) ^ m;
            case 56: return Math.min(l, r) | 0;
            case 57: return Math.max(l ^ m, r ^ m) ^ m;
            case 58: return Math.max(l, r) | 0;
            case 59: return hmul_u32(l, r) | 0;
            case 60: return hmul_i32(l, r);
            case 61: return clmul_u32(l, r);
            case 62: return clpow_u32(l, r);
            case 63: return ormul_u32(l, r);
        }
    }
    Binary.prototype.eval = function (vars) {
        var l = this.l.eval(vars) | 0;
        var r = this.r.eval(vars) | 0;
        return evalBinary(this.op, l, r);
    };
    function Assoc(op, operands) {
        Node.call(this);
        // inline nested assocs with the same op
        operands = operands.reduce(function (list, x) {
            if (x.type == 'assoc' && x.op == op)
                return list.concat(x.originalOperands);
            else
                return list.concat([x]);
        }, []);
        this.originalOperands = operands;
        var orderedoperands = operands;
        if (commutative[op]) {
            orderedoperands = operands.slice(0);
            orderedoperands.sort(function (a, b) { return a.hash - b.hash; });
        }
        this.hash = orderedoperands.reduce(function (a, b) { return 31 * a + b.hash | 0; }, op * 1009);
        this.hash2 = 0;
        this.op = op;
        this.operands = orderedoperands;
        this.type = 'assoc';
        var opweight = 1.0;
        if (op >= 4)
            opweight = 1.1;
        if (op == 10 || op == 11 || op == 32 || op == 33 || op == 34 || op == 35)
            opweight = 4.0;
        this.weight = operands.reduce(function (a, b) { return a + b.weight; }, opweight * (this.operands.length - 1));
    }
    Assoc.prototype = Object.create(Node.prototype);
    Assoc.prototype.constructor = Assoc;
    Assoc.prototype.equals = function (node) {
        if (node.hash != this.hash || node.type != 'assoc' || node.op != this.op || node.operands.length != this.operands.length)
            return false;
        for (var i = 0; i < this.operands.length; i++)
            if (!this.operands[i].equals(node.operands[i]))
                return false;
        return true;
    };
    Assoc.prototype.equals2 = function (node) {
        if (node.hash != this.hash || node.type != 'assoc' || node.op != this.op || node.originalOperands.length != this.originalOperands.length)
            return false;
        for (var i = 0; i < this.originalOperands.length; i++)
            if (!this.originalOperands[i].equals2(node.originalOperands[i]))
                return false;
        return true;
    };
    Assoc.prototype.removeDummy = function () {
        var newoperands = [];
        for (var i = 0; i < this.originalOperands.length; i++)
            newoperands[i] = this.originalOperands[i].removeDummy();
        for (var i = 0; i < this.originalOperands.length; i++)
            if (newoperands[i].id != this.originalOperands[i].id)
                return new Assoc(this.op, newoperands);
        return this;
    };
    Assoc.prototype.constantFold = function (nrec) {
        if (commutative[this.op]) {
            var operands = null;
            // if non-recursive, use operands directly
            if (nrec)
                operands = this.operands;
            // otherwise, fold them first
            else
                operands = this.operands.map(function (x) { return x.constantFold(false); });
            // take all the constants,
            var constants = operands.filter(function (x) { return x.type == 'const'; });
            if (constants.length < 2)
                return this;
            // fold them together
            var op = this.op;
            var c = constants.map(function (x) { return x.value; })
                .reduce(function (l, r) { return evalBinary(op, l, r); });
            // replace all the constants by the folded value
            var nc = operands.filter(function (x) { return x.type != 'const'; });
            nc.push(new Constant(c));
            if (nc.length == 1)
                return nc[0];
            return new Assoc(this.op, nc);
        }
        else {
            // if not commutative, only fold from left to right
            var newoperands = this.operands.slice(0);
            var r = false;
            for (var i = 1; i < newoperands.length; i++) {
                if (newoperands[i - 1].type == 'const' && newoperands[i].type == 'const') {
                    var c = new Constant(evalBinary(this.op, newoperands[i - 1].value, newoperands[i].value));
                    newoperands[i - 1] = null;
                    newoperands[i] = c;
                    r = true;
                }
            }
            if (r) {
                newoperands = newoperands.filter(function (x) { return x != null; });
                if (newoperands.length == 1)
                    return newoperands[0];
                return new Assoc(this.op, newoperands);
            }
        }
        return this;
    };
    Assoc.prototype.containsDoubleUnary = function () {
        return this.operands.reduce(function (sum, x) { return sum + x.containsDoubleUnary(); }, 0);
    };
    Assoc.prototype.copy = function () {
        return new Assoc(this.op, this.originalOperands.map(function (x) { return x.copy(); }));
    };
    Assoc.prototype.print = function (varmap) {
        if (this.op >= 55)
            return ops[this.op].substr(1) + "(" + this.originalOperands.join(", ") + ")";
        var m = this.originalOperands.map(function (x) {
            var inner = x.print(varmap);
            if (x.type == 'bin' || x.type == 'ter' || x.type == 'assoc')
                return "(" + inner + ")";
            else
                return inner;
        });
        return m.join(" " + ops[this.op] + " ");
    };
    Assoc.prototype.eval = function (vars) {
        var op = this.op;
        return this.originalOperands.reduce(function (l, r) {
            var lv;
            if (l instanceof Node)
                lv = l.eval(vars);
            else
                lv = l;
            return evalBinary(op, lv, r.eval(vars));
        });
    };
    Assoc.prototype.toBddFunc = function () {
        var op = this.op;
        return this.originalOperands.reduce(function (l, r) {
            if (l instanceof BDDFunction)
                return binaryToBddFunc(op, l, r.toBddFunc());
            else
                return binaryToBddFunc(op, l.toBddFunc(), r.toBddFunc());
        });
    };
    Assoc.prototype.toCircuitFunc = function () {
        var op = this.op;
        return this.originalOperands.reduce(function (l, r) {
            if (l instanceof CFunction)
                return binaryToCircuitFunc(op, l, r.toCircuitFunc());
            else
                return binaryToCircuitFunc(op, l.toCircuitFunc(), r.toCircuitFunc());
        });
    };
    function Ternary(cond, t, f) {
        Node.call(this);
        //if (cond == null || t == null || f == null) debugger;
        this.hash = (t.hash * 31) ^ (f.hash * 1009) ^ (cond.hash * 65521) ^ 0xdeadbeef;
        this.hash2 = (cond.hash2 & 15) | ((t.hash2 & 15) << 4) | ((f.hash2 & 15) << 8) | 0x7000;
        this.cond = cond;
        this.t = t;
        this.f = f;
        this.type = 'ter';
        this.weight = 1.0 + cond.weight + t.weight + f.weight;
    }
    Ternary.prototype = Object.create(Node.prototype);
    Ternary.prototype.constructor = Ternary;
    Ternary.prototype.equals = function (node) {
        return node.type == 'ter' && this.cond.equals(node.cond) && this.t.equals(node.t) && this.f.equals(node.f);
    };
    Ternary.prototype.equals2 = function (node) {
        return node.type == 'ter' && this.cond.equals2(node.cond) && this.t.equals2(node.t) && this.f.equals2(node.f);
    };
    Ternary.prototype.print = function (varmap) {
        return "(" + this.cond.print(varmap) + ") ? (" + this.t.print(varmap) + ") : (" + this.f.print(varmap) + ")";
    };
    Ternary.prototype.toBddFunc = function () {
        return BDDFunction.mux(this.cond.toBddFunc(), this.f.toBddFunc(), this.t.toBddFunc());
    };
    Ternary.prototype.toCircuitFunc = function () {
        return CFunction.mux(this.cond.toCircuitFunc(), this.f.toCircuitFunc(), this.t.toCircuitFunc());
    };
    Ternary.prototype.removeDummy = function () {
        var cond = this.cond.removeDummy();
        var t = this.t.removeDummy();
        var f = this.f.removeDummy();
        if (this.cond.id != cond.id ||
            this.t.id != t.id ||
            this.f.id != f.id)
            return new Ternary(cond, t, f);
        return this;
    };
    Ternary.prototype.constantFold = function (nrec) {
        var cond = nrec ? this.cond : this.cond.constantFold(false);
        var t = nrec ? this.t : this.t.constantFold(false);
        var f = nrec ? this.f : this.f.constantFold(false);
        if (cond.type == 'const' &&
            t.type == 'const' &&
            f.type == 'const') {
            return new Constant((cond.value & t.value) | (~cond.value & f.value));
        }
        if (cond.id != this.cond.id ||
            t.id != this.t.id ||
            f.id != this.f.id)
            return new Ternary(cond, t, f);
        return this;
    };
    Ternary.prototype.eval = function (vars) {
        var c = this.cond.eval(vars) | 0;
        var t = this.t.eval(vars) | 0;
        var f = this.f.eval(vars) | 0;
        return (c & t) | (~c & f);
    };
    Ternary.prototype.containsDoubleUnary = function () {
        return this.cond.containsDoubleUnary() + this.t.containsDoubleUnary() + this.f.containsDoubleUnary();
    };
    Ternary.prototype.copy = function () {
        return new Ternary(this.cond.copy(), this.t.copy(), this.f.copy());
    };
    function Fun(name, args) {
        Node.call(this);
        this.hash = args.reduce(function (a, b) {
            return 31 * a + b.hash | 0;
        }, 0xcafebabe);
        this.hash2 = 0;
        this.fun = name;
        this.args = args;
        this.type = 'fun';
        if (name.startsWith("$_mm"))
            this.fun = name.substr(1);
        this.weight = args.reduce(function (a, b) {
            return a + b.weight;
        }, 1.0);
    }
    // structural equality with commutivity
    Fun.prototype.equals = function (node) {
        if (node.type != 'fun' ||
            node.fun != this.fun ||
            node.args.length != this.args.length)
            return false;
        for (var i = 0; i < this.args.length; i++)
            if (!this.args[i].equals(node.args[i]))
                return false;
        return true;
    };
    // structural equality without commutivity
    Fun.prototype.equals2 = function (node) {
        if (node.type != 'fun' ||
            node.fun != this.fun ||
            node.args.length != this.args.length)
            return false;
        for (var i = 0; i < this.args.length; i++)
            if (!this.args[i].equals2(node.args[i]))
                return false;
        return true;
    };
    Fun.prototype.print = function (varmap) {
        return this.fun + "(" + this.args.join(", ") + ")";
    };
    Fun.prototype.toBddFunc = function () {
        var a = this.args.map(function (x) { return x.toBddFunc(); });
        switch (this.fun) {
            case "$fixscale":
                return BDDFunction.fixscale(a[0], a[1], a[2]);
            case "$fixmul_u":
                return BDDFunction.fixmul(a[0], a[1], a[2], false);
            case "$gf2affine":
                return BDDFunction.gf2affine(a[0], a[1], a[2]);
            default:
                throw "unimplemented function";
        }
        return null;
    };
    Fun.prototype.toCircuitFunc = function () {
        var a = this.args.map(function (x) { return x.toCircuitFunc(); });
        switch (this.fun) {
            case "$fixscale":
                return CFunction.fixscale(a[0], a[1], a[2]);
            case "$fixmul_u":
                return CFunction.fixmul(a[0], a[1], a[2], false);
            default:
                throw "unimplemented function";
        }
        return null;
    };
    Fun.prototype.toSSECircuitFunc = function () {
        var a = this.args.map(function (x) { return x.toSSECircuitFunc(); });
        if (this.fun.startsWith("_mm") && SSECFunction[this.fun])
            return SSECFunction[this.fun].apply(SSECFunction, __spread(a));
    };
    Fun.prototype.removeDummy = function () {
        var args = this.args.map(function (x) { return x.removeDummy(); });
        for (var i = 0; i < args.length; i++) {
            if (args[i].id != this.args[i].id)
                return new Fun(this.fun, args);
        }
        return this;
    };
    Fun.prototype.constantFold = function (nrec) {
        var args = this.args.map(function (x) { return nrec ? x : x.constantFold(false); });
        if (args.every(function (x) { return x.type == 'const'; })) {
            return new Constant(BDDFunction.to_constant(new Fun(this.fun, args).toBddFunc()));
        }
        for (var i = 0; i < args.length; i++) {
            if (args[i].id != this.args[i].id)
                return new Fun(this.fun, args);
        }
        return this;
    };
    Fun.prototype.containsDoubleUnary = function () {
        return this.args.reduce(function (a, b) {
            return a + b.containsDoubleUnary();
        }, 0);
    };
    Fun.prototype.copy = function () {
        return new Fun(this.fun, this.args);
    };
    Fun.prototype.eval = function (vars) {
        var a = this.args.map(function (a) { return BDDFunction.constant(a.eval(vars)); });
        switch (this.fun) {
            case "$fixscale":
                return BDDFunction.to_constant(BDDFunction.fixscale(a[0], a[1], a[2]));
            case "$fixmul_u":
                return BDDFunction.to_constant(BDDFunction.fixmul(a[0], a[1], a[2]));
            case "$gf2affine":
                return BDDFunction.to_constant(BDDFunction.gf2affine(a[0], a[1], a[2]));
            default:
                throw "unimplemented function";
        }
    };
    Fun.prototype.sseeval = function (vars) {
        if (this.fun.startsWith("_mm_") ||
            this.fun.startsWith("_mm256_")) {
            var a = this.args.map(function (x) { return x.sseeval(vars); });
            return SSECFunction[this.fun].apply(SSECFunction, __spread(a));
        }
    };
    function Let(pairs, expr) {
        Node.call(this);
        // the hashes don't matter because Let is only used in output
        this.type = 'let';
        this.pairs = pairs;
        this.expr = expr;
    }
    Let.prototype.print = function (varmap) {
        var str = "let ";
        varmap = varmap.slice();
        for (var i = 0; i < this.pairs.length; i++) {
            if (i != 0)
                str += ", ";
            var p = this.pairs[i];
            if (p.name) {
                str += p.name + " = " + p.expr.print(varmap);
                varmap.push(p.name);
            }
            else
                str += p.v.print(varmap) + " = " + p.expr.print(varmap);
        }
        return str + " in " + this.expr.print(varmap);
    };
    Let.prototype.constantFold = function (nrec) {
        this.expr = this.expr.constantFold(nrec);
        return this;
    };
    Node.fromBareObject = function (expr) {
        function clone(expr) {
            switch (expr.type) {
                case 'const':
                    return new Constant(expr.value);
                case 'var':
                    return new Variable(expr.index);
                case 'un':
                    return new Unary(expr.op, Node.fromBareObject(expr.value));
                case 'bin':
                    return new Binary(expr.op, Node.fromBareObject(expr.l), Node.fromBareObject(expr.r));
                case 'ter':
                    return new Ternary(Node.fromBareObject(expr.cond), Node.fromBareObject(expr.t), Node.fromBareObject(expr.f));
                case 'fun':
                    return new Fun(expr.fun, expr.args.map(Node.fromBareObject));
                default:
                    debugger;
                    alert("Missing case in Node.fromBareObject");
            }
        }
        ;
        if (expr == null)
            return null;
        var c = clone(expr);
        c.id = expr.id;
        return c;
    };
    Node.normalize = function (expr) {
        switch (expr.type) {
            default: return expr;
            case 'un':
                var inner = Node.normalize(expr.value);
                return inner.id == expr.value.id ? expr : new Unary(expr.op, inner);
            case 'bin':
                var l = Node.normalize(expr.l);
                var r = Node.normalize(expr.r);
                if (associative[expr.op])
                    return new Assoc(expr.op, [l, r]);
                if (l.id != expr.l.id || r.id != expr.r.id)
                    return new Binary(expr.op, l, r);
                return expr;
            case 'assoc':
                var args = expr.originalOperands.map(Node.normalize);
                for (var i = 0; i < args.length; i++)
                    if (args[i].id != expr.originalOperands[i].id)
                        return new Assoc(expr.op, args);
                return expr;
            case 'ter':
                var c = Node.normalize(expr.cond);
                var t = Node.normalize(expr.t);
                var f = Node.normalize(expr.f);
                if (c.id != expr.cond.id || t.id != expr.t.id || f.id != expr.f.id)
                    return new Ternary(c, t, f);
                return expr;
            case 'fun':
                var args = expr.args.map(Node.normalize);
                for (var i = 0; i < args.length; i++)
                    if (args[i].id != expr.args[i].id)
                        return new Fun(expr.fun, args);
                return expr;
        }
    };
    Node.AnalyzeProperties = function (data, vars, expr, callback) {
        if (!data.properties)
            data.properties = {};
        switch (vars.length) {
            default: return;
            case 1:
                function collectAssoc(expr, op) {
                    if (expr.type === "bin" && expr.op === op)
                        return collectAssoc(expr.l, op).concat(collectAssoc(expr.r, op));
                    else
                        return [expr];
                }
                function invert(expr, inv) {
                    switch (expr.type) {
                        default: return null;
                        case "var": return inv;
                        case "un":
                            // ~, -, reverse
                            if (expr.op == 0 || expr.op == 1 || expr.op == 5)
                                return invert(expr.value, new Unary(expr.op, inv));
                            return null;
                        case "bin":
                            var lcf = null, rcf = null;
                            // ^, +, - of an invertible expr with a constant
                            if (expr.op == 3 || expr.op == 4 || expr.op == 5) {
                                var undoop = [0, 0, 0, 3, 5, 4];
                                lcf = expr.l.constantFold();
                                if (lcf.type == "const") {
                                    if (expr.op != 5)
                                        return invert(expr.r, lcf.value == 0 ? inv : new Binary(undoop[expr.op], inv, lcf));
                                    else
                                        return invert(expr.r, new Binary(5, lcf, inv));
                                }
                                rcf = expr.r.constantFold();
                                if (rcf.type == "const")
                                    return invert(expr.l, rcf.value == 0 ? inv : new Binary(undoop[expr.op], inv, rcf));
                            }
                            // mul by odd
                            if (expr.op == 11) {
                                lcf = lcf || expr.l.constantFold();
                                var theConst = lcf;
                                var theRest = expr.r;
                                if (theConst.type != "const") {
                                    rcf = rcf || expr.r.constantFold();
                                    theConst = rcf;
                                    theRest = expr.l;
                                }
                                if (theConst.type == "const") {
                                    if ((theConst.value & 1) == 0)
                                        return null;
                                    var x = mulinv(theConst.value);
                                    return invert(theRest, new Binary(11, inv, new Constant(x)));
                                }
                                return null;
                            }
                            // clmul by odd
                            if (expr.op == 61) {
                                lcf = lcf || expr.l.constantFold();
                                var theConst = lcf;
                                var theRest = expr.r;
                                if (theConst.type != "const") {
                                    rcf = rcf || expr.r.constantFold();
                                    theConst = rcf;
                                    theRest = expr.l;
                                }
                                if (theConst.type == "const") {
                                    if ((theConst.value & 1) == 0)
                                        return null;
                                    var x = clinv(theConst.value);
                                    return invert(theRest, new Binary(61, inv, new Constant(x)));
                                }
                                return null;
                            }
                            // clmul by xor/left-shift, or mirrored variant
                            // or mul by add/left-shift
                            if (expr.op == 3 || expr.op == 4) {
                                var op = expr.op;
                                var parts = collectAssoc(expr, op);
                                // one of the parts needs to be the unshifted version
                                var unshifted = parts.find(function (p) { return p.type != "bin" || (p.op != 6 && p.op != 31); });
                                // and one of the parts needs to be the shifted version
                                var shifted = parts.find(function (p) { return p.type == "bin" && (p.op == 6 || p.op == 31); });
                                if (!unshifted || !shifted)
                                    return null;
                                var shiftop = shifted.op;
                                // only XOR can be paired with right shift
                                if (op == 4 && shiftop == 31)
                                    return null;
                                // all of the parts need to be either the unshifted version or the shifted version
                                if (parts.every(function (p) {
                                    if (p.id == unshifted.id || p.equals(unshifted))
                                        return true;
                                    else if (p.type != "bin" || p.op != shiftop)
                                        return false;
                                    else if (p.r.type != "const")
                                        return false;
                                    else
                                        return p.l.equals(unshifted);
                                })) {
                                    // find multiplier
                                    function xor(a, b) { return a ^ b; }
                                    function add(a, b) { return a + b | 0; }
                                    var combiner = op == 3 ? xor : add;
                                    var M = 0;
                                    for (var i = 0; i < parts.length; i++) {
                                        var p = parts[i];
                                        if (p.id == unshifted.id || p.equals(unshifted))
                                            M = combiner(M, 1);
                                        else if (p.type == "bin" && p.op == shiftop && p.r.type == "const")
                                            M = combiner(M, 1 << p.r.value);
                                        else {
                                            // shouldn't happen
                                            debugger;
                                            return null;
                                        }
                                    }
                                    // multiplier must be odd otherwise it has no inverse
                                    if ((M & 1) == 0)
                                        return null;
                                    // for addition/left-shift use a multiply
                                    if (op == 4 && shiftop == 6) {
                                        var x = mulinv(M);
                                        return invert(unshifted, new Binary(11, inv, new Constant(x)));
                                    }
                                    // for xor with left-shift use clmul, otherwise xor/right shift combo
                                    if (op == 3) {
                                        function makeOneStepXorshift(M, base, shiftop) {
                                            var e = base;
                                            M &= -2;
                                            while (M != 0) {
                                                var m = M & -M;
                                                var sh = ctz(m);
                                                M &= M - 1;
                                                e = new Binary(3, e, new Binary(shiftop, base, new Constant(sh)));
                                            }
                                            return e;
                                        }
                                        var x = clinv(M);
                                        if (shiftop == 6)
                                            return invert(unshifted, new Binary(61, inv, new Constant(x)));
                                        else {
                                            var f = clfactor(x);
                                            var x = inv;
                                            if (x.type == "var")
                                                x = makeOneStepXorshift(f.shift(), x, shiftop);
                                            if (f.length > 0) {
                                                var p1 = f.map(function (M) { return makeOneStepXorshift(M, new Variable(2), shiftop); });
                                                p1.unshift(x);
                                                var last = p1.pop();
                                                var p2 = p1.map(function (p) { return { v: new Variable(2), expr: p }; });
                                                x = new Let(p2, last);
                                            }
                                            return invert(unshifted, x);
                                        }
                                    }
                                }
                            }
                            // rotate of invertible by constant
                            if (expr.op == 8 || expr.op == 9) {
                                rcf = rcf || expr.r.constantFold();
                                if (rcf.type == "const")
                                    return invert(expr.l, rcf.value == 0 ? inv : new Binary(expr.op ^ 1, inv, rcf));
                            }
                            return null;
                    }
                }
                var inv = invert(expr, new Variable(1));
                if (inv) {
                    inv = inv.constantFold();
                    if (inv.type != "var") {
                        var newvar = data.varmap[0] == "r" ? "x" : "r";
                        data.varmap[1] = newvar;
                        data.varmap[2] = data.varmap[0] == "t" ? "y" : "t";
                        data.properties.inverse = inv;
                        data.properties.inverseproof = "let " + newvar + " = " + expr.print(data.varmap) + " in (" + inv.print(data.varmap) + ") == " + data.varmap[0];
                    }
                    else
                        delete data.properties.inverse;
                    if (callback)
                        callback(data);
                }
                break;
        }
    };
    // END - expr
    // START - bdd
    function getmilitime() {
        return new Date().getTime();
    }
    var SparseArray = /** @class */ (function () {
        function SparseArray() {
            this._o = new Map();
        }
        SparseArray.prototype.get = function (i) {
            var val = this._o.get(i);
            if (val === undefined) {
                return 0;
            }
            return val;
        };
        SparseArray.prototype.set = function (k, v) {
            this._o.set(k, v);
        };
        SparseArray.prototype.length = function () {
            return this._o.size;
        };
        return SparseArray;
    }());
    var bdd = {
        reset: function () {
            if (!Int32Array.prototype.fill) {
                Int32Array.prototype.fill = function (value) {
                    for (var i = 0; i < this.length; i++)
                        this[i] = value;
                };
            }
            if (!Uint8Array.prototype.fill) {
                Uint8Array.prototype.fill = function (value) {
                    for (var i = 0; i < this.length; i++)
                        this[i] = value;
                };
            }
            if (!this._v) {
                this._v = new SparseArray();
                this._lo = new SparseArray();
                this._hi = new SparseArray();
                this._memo = new Int32Array(1048573);
                this._memokey1 = new Int32Array(1048573);
                this._memokey2 = new Int32Array(1048573);
                this._memokey3 = new Int32Array(1048573);
                this._memoop = new Uint8Array(1048573);
            }
            else {
                this._lo = new SparseArray();
                this._hi = new SparseArray();
                this._memoop.fill(0);
            }
        },
        viz: function () {
            var img = new Uint8ClampedArray(1920 * 4370 * 4);
            var streak = 0;
            for (var i = 0; i < this._hi.length(); i++) {
                if (this._lo.get(i) != 0 ||
                    this._hi.get(i) != 0) {
                    if (streak > 1000) {
                        img[i * 4 + 2] = 255;
                    }
                    else {
                        img[i * 4] = 0xFF;
                        img[i * 4 + 1] = streak * 16;
                        img[i * 4 + 2] = (streak - 16) * 16;
                    }
                    img[i * 4 + 3] = 0xFF;
                    streak++;
                }
                else {
                    img[i * 4 + 3] = 0xFF;
                    streak = 0;
                }
            }
            return new ImageData(img, 1920, 4370);
        },
        mk: function (v, lo, hi) {
            var invert = hi >> 31;
            hi ^= invert;
            lo ^= invert;
            if (lo == hi)
                return lo ^ invert;
            var hash2 = ((((v << 17) - v) ^ ((lo << 13) - lo) ^ ((hi << 16) + hi)) & 0x7fffffff) % 8388593;
            var hash1 = hash2 & -8;
            var upper = (hash1 + 1000) % 8388593;
            if (hash1 == 0)
                hash1 = 1;
            if (hash2 == 0)
                hash2 = 1;
            if (this._lo.get(hash1) == lo && this._hi.get(hash1) == hi && this._v.get(hash1) == v)
                return hash1 ^ invert;
            if (this._lo.get(hash2) == lo && this._hi.get(hash2) == hi && this._v.get(hash2) == v)
                return hash2 ^ invert;
            for (var i = hash1; i != upper; i = (i + 1) % 8388593) {
                if (i == 0)
                    continue;
                if ((this._lo.get(i) | this._hi.get(i)) == 0)
                    break;
                if (this._lo.get(i) == lo && this._hi.get(i) == hi && this._v.get(i) == v)
                    return i ^ invert;
            }
            if (this._lo.get(hash1) == 0 && this._hi.get(hash1) == 0) {
                this._lo.set(hash1, lo);
                this._hi.set(hash1, hi);
                this._v.set(hash1, v);
                return hash1 ^ invert;
            }
            if (this._lo.get(hash2) == 0 && this._hi.get(hash2) == 0) {
                this._lo.set(hash2, lo);
                this._hi.set(hash2, hi);
                this._v.set(hash2, v);
                return hash2 ^ invert;
            }
            for (var i = hash1; i != upper; i = (i + 1) % 8388593) {
                if (i == 0)
                    continue;
                if ((this._lo.get(i) | this._hi.get(i)) == 0) {
                    this._lo.set(i, lo);
                    this._hi.set(i, hi);
                    this._v.set(i, v);
                    return i ^ invert;
                }
            }
            throw "BDD full";
        },
        or: function (f, g, timelimit) {
            return ~this.and(~f, ~g, timelimit);
        },
        and: function (f, g, timelimit) {
            if (f == -1 || g == -1 || f == 0 || g == 0 || f == ~g || f == g)
                return f & g;
            var key1 = Math.min(f, g);
            var key2 = Math.max(f, g);
            var hash = ((((key1 << 17) - key1) ^ ((key2 << 16) + key2)) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 1 && this._memokey1[hash] == key1 && this._memokey2[hash] == key2)
                return this._memo[hash];
            if (timelimit && getmilitime() >= timelimit)
                throw "BDD timeout";
            else if (!timelimit)
                timelimit = getmilitime() + 100;
            var invf = f >> 31;
            var invg = g >> 31;
            var fv = this._v.get(f ^ invf);
            var gv = this._v.get(g ^ invg);
            var flo = this._lo.get(f ^ invf) ^ invf;
            var glo = this._lo.get(g ^ invg) ^ invg;
            var fhi = this._hi.get(f ^ invf) ^ invf;
            var ghi = this._hi.get(g ^ invg) ^ invg;
            var value = 0;
            if (fv == gv)
                value = this.mk(fv, this.and(flo, glo, timelimit), this.and(fhi, ghi, timelimit));
            else if (fv < gv)
                value = this.mk(fv, this.and(flo, g, timelimit), this.and(fhi, g, timelimit));
            else
                value = this.mk(gv, this.and(f, glo, timelimit), this.and(f, ghi, timelimit));
            this._memoop[hash] = 1;
            this._memokey1[hash] = key1;
            this._memokey2[hash] = key2;
            this._memo[hash] = value;
            return value;
        },
        xor: function (f, g, timelimit) {
            if (f == 0 || g == 0 || f == -1 || g == -1 || f == g || f == ~g)
                return f ^ g;
            var invert = (f ^ g) >> 31;
            f ^= f >> 31;
            g ^= g >> 31;
            var key1 = Math.min(f, g);
            var key2 = Math.max(f, g);
            var hash = ((((key1 << 17) - key1) ^ ((key2 << 16) + key2) ^ 0xdeadbeef) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 2 && this._memokey1[hash] == key1 && this._memokey2[hash] == key2)
                return this._memo[hash] ^ invert;
            if (timelimit && getmilitime() >= timelimit)
                throw "BDD timeout";
            else if (!timelimit)
                timelimit = getmilitime() + 100;
            var fv = this._v.get(f);
            var gv = this._v.get(g);
            var flo = this._lo.get(f);
            var glo = this._lo.get(g);
            var fhi = this._hi.get(f);
            var ghi = this._hi.get(g);
            var value = 0;
            if (fv == gv)
                value = this.mk(fv, this.xor(flo, glo, timelimit), this.xor(fhi, ghi, timelimit));
            else if (fv < gv)
                value = this.mk(fv, this.xor(flo, g, timelimit), this.xor(fhi, g, timelimit));
            else
                value = this.mk(gv, this.xor(f, glo, timelimit), this.xor(f, ghi, timelimit));
            this._memoop[hash] = 2;
            this._memokey1[hash] = key1;
            this._memokey2[hash] = key2;
            this._memo[hash] = value;
            return value ^ invert;
        },
        xorxor: function (f, g, h, timelimit) {
            return this.xor(this.xor(f, g), h);
            function issink(x) {
                return (x == 0 || x == -1) ? 1 : 0;
            }
            if (f == ~g || f == ~h || g == ~h)
                return f ^ g ^ h;
            if ((f ^ (f >> 31)) == 0 ||
                (g ^ (g >> 31)) == 0)
                return this.xor(f ^ g, h);
            if ((h ^ (h >> 31)) == 0)
                return this.xor(f, g ^ h);
            if (issink(f) + issink(g) + issink(h) >= 2)
                return f ^ g ^ h;
            var invert = (f ^ g ^ h) >> 31;
            f ^= f >> 31;
            g ^= g >> 31;
            h ^= h >> 31;
            var key1 = Math.min(f, g, h);
            var key2 = Math.max(f, g, h);
            var key3 = (f ^ g ^ h) ^ (key1 ^ key2);
            var hash = ((((key1 << 17) - key1) ^ ((key2 << 16) + key2) ^ ((key3 << 19) - key3)) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 4 && this._memokey1[hash] == key1 && this._memokey2[hash] == key2 && this._memokey3[hash] == key3)
                return this._memo[hash] ^ invert;
            if (timelimit && getmilitime() >= timelimit)
                throw "BDD timeout";
            var fv = this._v[f];
            var gv = this._v[g];
            var hv = this._v[h];
            var minv = Math.min(fv, gv, hv);
            var fl = f, fh = f, gl = g, gh = g, hl = h, hh = h;
            if (fv == minv) {
                fl = this._lo[f];
                fh = this._hi[f];
            }
            if (gv == minv) {
                gl = this._lo[g];
                gh = this._hi[g];
            }
            if (hv == minv) {
                hl = this._lo[h];
                hh = this._hi[h];
            }
            var res = this.mk(minv, this.xorxor(fl, gl, hl, timelimit), this.xorxor(fh, gh, hh, timelimit));
            this._memoop[hash] = 4;
            this._memokey1[hash] = f;
            this._memokey2[hash] = g;
            this._memokey3[hash] = h;
            this._memo[hash] = res;
            return res ^ invert;
        },
        carry: function (f, g, h, timelimit) {
            function isone(x) {
                return (x == -1) ? 1 : 0;
            }
            if (isone(f) + isone(g) + isone(h) >= 2 ||
                f == ~g && h == -1 ||
                f == ~h && g == -1 ||
                g == ~h && f == -1)
                return -1;
            if (f == ~g)
                return h;
            if (f == ~h)
                return g;
            if (g == ~h)
                return f;
            if (f == 0 || g == 0)
                return this.and(f | g, h);
            if (h == 0)
                return this.and(f, g);
            if (f == -1)
                return this.or(g, h);
            if (g == -1)
                return this.or(f, h);
            if (h == -1)
                return this.or(f, g);
            var key1 = Math.min(f, g, h);
            var key2 = Math.max(f, g, h);
            var key3 = (f ^ g ^ h) ^ (key1 ^ key2);
            var hash = ((((key1 << 17) - key1) ^ ((key2 << 16) + key2) ^ ((key3 << 19) - key3)) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 5 && this._memokey1[hash] == key1 && this._memokey2[hash] == key2 && this._memokey3[hash] == key3)
                return this._memo[hash];
            if (timelimit && getmilitime() >= timelimit)
                throw "BDD timeout";
            var finv = f >> 31;
            var ginv = g >> 31;
            var hinv = h >> 31;
            var fv = this._v.get(f ^ finv);
            var gv = this._v.get(g ^ ginv);
            var hv = this._v.get(h ^ hinv);
            var minv = Math.min(fv, gv, hv);
            var fl = f, fh = f, gl = g, gh = g, hl = h, hh = h;
            if (fv == minv) {
                fl = this._lo.get(f ^ finv) ^ finv;
                fh = this._hi.get(f ^ finv) ^ finv;
            }
            if (gv == minv) {
                gl = this._lo.get(g ^ ginv) ^ ginv;
                gh = this._hi.get(g ^ ginv) ^ ginv;
            }
            if (hv == minv) {
                hl = this._lo.get(h ^ hinv) ^ hinv;
                hh = this._hi.get(h ^ hinv) ^ hinv;
            }
            var res = this.mk(minv, this.carry(fl, gl, hl, timelimit), this.carry(fh, gh, hh, timelimit));
            this._memoop[hash] = 5;
            this._memokey1[hash] = key1;
            this._memokey2[hash] = key2;
            this._memokey3[hash] = key3;
            this._memo[hash] = res;
            return res;
        },
        mux: function (f, g, h) {
            if (f == 0 || g == h)
                return g;
            else if (f == -1)
                return h;
            else if (g == ~h)
                return this.xor(f, g);
            else if (g == 0 || f == g)
                return this.and(f, h);
            else if (h == -1 || f == h)
                return ~this.and(~f, ~g);
            else if (g == -1)
                return ~this.and(f, ~h);
            else if (h == 0)
                return this.and(g, ~f);
            else if (f < 0)
                return this.mux(~f, h, g);
            var hash = ((((f << 17) - f) ^ ((g << 16) + g) ^ ((h << 19) - h)) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 3 && this._memokey1[hash] == f && this._memokey2[hash] == g && this._memokey3[hash] == h)
                return this._memo[hash];
            var invg = g >> 31;
            var invh = h >> 31;
            var fv = this._v.get(f);
            var gv = this._v.get(g ^ invg);
            var hv = this._v.get(h ^ invh);
            var minv = Math.min(fv, gv, hv);
            var fl = f, fh = f, gl = g, gh = g, hl = h, hh = h;
            if (fv == minv) {
                fl = this._lo.get(f);
                fh = this._hi.get(f);
            }
            if (gv == minv) {
                gl = this._lo.get(g ^ invg) ^ invg;
                gh = this._hi.get(g ^ invg) ^ invg;
            }
            if (hv == minv) {
                hl = this._lo.get(h ^ invh) ^ invh;
                hh = this._hi.get(h ^ invh) ^ invh;
            }
            var rl = this.mux(fl, gl, hl), rh = this.mux(fh, gh, hh);
            var value = this.mk(minv, rl, rh);
            this._memoop[hash] = 3;
            this._memokey1[hash] = f;
            this._memokey2[hash] = g;
            this._memokey3[hash] = h;
            this._memo[hash] = value;
            return value;
        },
        quantU: function (f, ql, qh) {
            if (f == 0 || f == -1)
                return f;
            var hash = ((f & 0x1fffffff) + ql * 1009 + qh) % 1048573;
            if (this._memoop[hash] == 6 && this._memokey1[hash] == f && this._memokey2[hash] == ql && this._memokey3[hash] == qh)
                return this._memo[hash];
            var inv = f >> 31;
            var fv = this._v.get(f ^ inv);
            var lo = this._lo.get(f ^ inv) ^ inv;
            var hi = this._hi.get(f ^ inv) ^ inv;
            var rl = this.quantU(lo, ql, qh);
            var rh = this.quantU(hi, ql, qh);
            var r;
            if ((fv & 63) >= ql && (fv & 63) <= qh)
                r = this.and(rl, rh);
            else
                r = this.mk(fv, rl, rh);
            this._memoop[hash] = 6;
            this._memokey1[hash] = f;
            this._memokey2[hash] = ql;
            this._memokey3[hash] = qh;
            this._memo[hash] = r;
            return r;
        },
        compose: function (f, replace) {
            var compmemo = new Int32Array(1048573);
            var compmemokey = new Int32Array(1048573);
            for (var i = 0; i < 1048573; i++)
                compmemokey[i] = -2147483648;
            function comp(f, replace) {
                if (f == 0 || f == -1)
                    return f;
                var hash = (f & 0x7fffffff) % 1048573;
                if (compmemokey[hash] == f)
                    return compmemo[hash];
                var invf = f >> 31;
                var fv = this._v.get(f ^ invf);
                var fl = this._lo.get(f ^ invf) ^ invf;
                var fh = this._hi.get(f ^ invf) ^ invf;
                var r = replace[fv];
                if (r == 0)
                    return comp(fl, replace);
                else if (r == 1)
                    return comp(fh, replace);
                else {
                    var l = comp(fl, replace);
                    var h = comp(fh, replace);
                    var res;
                    if (r === void (0))
                        res = this.mk(fv, l, h);
                    else
                        res = this.mux(f, l, h);
                    compmemokey[hash] = f;
                    compmemo[hash] = res;
                    return res;
                }
            }
            return comp(f, replace);
        },
        incv: function (f) {
            if (f == 0 || f == -1)
                return f;
            var invert = f >> 31;
            f ^= f >> 31;
            var hash = f % 1048573;
            if (this._memoop[hash] == 8 && this._memokey1[hash] == f)
                return this._memo[hash] ^ invert;
            var fv = this._v.get(f);
            var flo = this._lo.get(f);
            var fhi = this._hi.get(f);
            var value = this.mk(fv + 1, this.incv(flo), this.incv(fhi));
            this._memoop[hash] = 8;
            this._memokey1[hash] = f;
            this._memo[hash] = value;
            return value ^ invert;
        },
        andIsZero: function (f, g) {
            if (f == -1 || g == -1 || f == 0 || g == 0 || f == ~g || f == g)
                return (f & g) == 0;
            var key1 = Math.min(f, g);
            var key2 = Math.max(f, g);
            var hash = ((((key1 << 17) - key1) ^ ((key2 << 16) + key2)) & 0x7fffffff) % 1048573;
            if (this._memoop[hash] == 7 && this._memokey1[hash] == key1 && this._memokey2[hash] == key2)
                return this._memo[hash];
            var invf = f >> 31;
            var invg = g >> 31;
            var fv = this._v.get(f ^ invf);
            var gv = this._v.get(g ^ invg);
            var flo = this._lo.get(f ^ invf) ^ invf;
            var glo = this._lo.get(g ^ invg) ^ invg;
            var fhi = this._hi.get(f ^ invf) ^ invf;
            var ghi = this._hi.get(g ^ invg) ^ invg;
            var value = false;
            if (fv == gv)
                value = this.andIsZero(flo, glo) && this.andIsZero(fhi, ghi);
            else if (fv < gv)
                value = this.andIsZero(flo, g) && this.andIsZero(fhi, g);
            else
                value = this.andIsZero(f, glo) && this.andIsZero(f, ghi);
            this._memoop[hash] = 7;
            this._memokey1[hash] = key1;
            this._memokey2[hash] = key2;
            this._memo[hash] = value;
            return value;
        },
        satCount: function (f, maxvar, remap) {
            var D = [];
            var _v = this._v;
            var _lo = this._lo;
            var _hi = this._hi;
            function sat(x, prevvar) {
                if (x == 0)
                    return new BigInt(0);
                else if (x == -1)
                    return new BigInt(1).shl(maxvar - prevvar - 1);
                var invx = x >> 31;
                var v = _v[x ^ invx];
                var rv = remap[v];
                var res;
                if (D[x] === void (0)) {
                    var lo = sat(_lo[x ^ invx] ^ invx, rv);
                    var hi = sat(_hi[x ^ invx] ^ invx, rv);
                    res = lo.add(hi);
                    D[x] = res;
                }
                else
                    res = D[x];
                return res.shl(rv - prevvar - 1);
            }
            return sat(f, -1);
        },
        indexedSat: function (f, index, maxvar, remap) {
            var _v = this._v;
            var _lo = this._lo;
            var _hi = this._hi;
            var havehad = 0;
            var res = new Int32Array(64);
            function findsat(cv, x, prevvar) {
                if (x == 0)
                    return false;
                if (x == -1) {
                    if (cv == 2048)
                        return havehad++ == index;
                    else {
                        var nextvar = cv + 1;
                        while (nextvar < 2048 && remap[nextvar] === void (0))
                            nextvar++;
                        if (findsat(nextvar, x, prevvar))
                            return true;
                        else if (findsat(nextvar, x, prevvar)) {
                            res[cv & 63] |= 1 << ((cv >> 6) ^ 31);
                            return true;
                        }
                        else
                            return false;
                    }
                }
                var invx = x >> 31;
                var v = _v[x ^ invx];
                var nextvar = cv + 1;
                while (nextvar < 2048 && remap[nextvar] === void (0))
                    nextvar++;
                if (v == cv) {
                    if (findsat(nextvar, _lo[x ^ invx] ^ invx, remap[v]))
                        return true;
                    else if (findsat(nextvar, _hi[x ^ invx] ^ invx, remap[v])) {
                        res[v & 63] |= 1 << ((v >> 6) ^ 31);
                        return true;
                    }
                    else
                        return false;
                }
                else {
                    if (findsat(nextvar, x, prevvar))
                        return true;
                    else if (findsat(nextvar, x, prevvar)) {
                        res[cv & 63] |= 1 << ((cv >> 6) ^ 31);
                        return true;
                    }
                    else
                        return false;
                }
            }
            var lowest = 0;
            while (remap[lowest] === void (0) && lowest < 2048)
                lowest++;
            if (findsat(lowest, f, -1))
                return res;
            else
                return undefined;
        },
        lowestSat: function (f) {
            if (f == 0)
                return null;
            var res = new Int32Array(64);
            for (var i = 0; i < res.length; i++) {
                res[i] = 0;
            }
            if (f == -1)
                return res;
            while (f != -1) {
                var invf = f >> 31;
                var v = this._v.get(f ^ invf);
                var lo = this._lo.get(f ^ invf) ^ invf;
                var hi = this._hi.get(f ^ invf) ^ invf;
                if (lo == 0) {
                    res[v & 63] |= 1 << ((v >> 6) ^ 31);
                    f = hi;
                }
                else
                    f = lo;
            }
            return res;
        },
        dump: function (f) {
            var D = [];
            var _v = this._v;
            var _lo = this._lo;
            var _hi = this._hi;
            function pdump(f) {
                if (D[f] === void (0)) {
                    D[f] = true;
                    if (f == 0 || f == -1)
                        return "";
                    var invf = f >> 31;
                    var fv = _v[f ^ invf];
                    var lo = _lo[f ^ invf] ^ invf;
                    var hi = _hi[f ^ invf] ^ invf;
                    var nodestring = f + " [label=\"x" + (fv & 63) + "_" + (fv >> 6 ^ 31) + "\"]";
                    var lostring = f + " -> ";
                    if (lo == 0)
                        lostring += "0 [style=\"dashed\"];";
                    else if (lo == -1)
                        lostring += "1 [style=\"dashed\"];";
                    else
                        lostring += lo + " [style=\"dashed\"];";
                    var histring = f + " -> ";
                    if (hi == 0)
                        histring += "0;";
                    else if (hi == -1)
                        histring += "1;";
                    else
                        histring += hi + ";";
                    return pdump(lo) + pdump(hi) + nodestring + lostring + histring;
                }
                else
                    return "";
            }
            return pdump(f);
        }
    };
    // END - bdd
    // START - bddfunction
    bdd.reset();
    function BDDFunction(bits, de) {
        this._bits = new Int32Array(bits);
        this._divideError = de;
    }
    BDDFunction.argument = function (argindex) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.mk(((i ^ 31) << 6) | argindex, 0, -1);
        }
        return new BDDFunction(bits, 0);
    };
    BDDFunction.constant = function (value) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = (value << (i ^ 31)) >> 31;
        }
        return new BDDFunction(bits, 0);
    };
    BDDFunction.to_constant = function (x) {
        var res = 0;
        for (var i = 0; i < 32; i++)
            res |= (1 << i) & x._bits[i];
        return res;
    };
    BDDFunction.not = function (x) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = ~x._bits[i];
        }
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.and = function (x, y) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.and(x._bits[i], y._bits[i]);
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.or = function (x, y) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.or(x._bits[i], y._bits[i]);
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.xor = function (x, y) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.xor(x._bits[i], y._bits[i]);
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.mux = function (x, y, z) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.mux(x._bits[i], y._bits[i], z._bits[i]);
        }
        return new BDDFunction(bits, bdd.or(bdd.or(x._divideError, y._divideError), z._divideError));
    };
    BDDFunction.add = function (x, y) {
        var timelimit = getmilitime() + 1000;
        var bits = new Int32Array(32);
        var carry = 0;
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.xorxor(x._bits[i], y._bits[i], carry, timelimit);
            if (i < 31) {
                carry = bdd.carry(carry, x._bits[i], y._bits[i], timelimit);
            }
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.add2 = function (x, y) {
        var bits = new Int32Array(32);
        var carry = 0;
        for (var i = 0; i < bits.length; i++) {
            var xy = bdd.xor(x._bits[i], y._bits[i]);
            bits[i] = bdd.xor(xy, carry);
            if (i < 31) {
                carry = bdd.carry(carry, x._bits[i], y._bits[i]);
            }
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.sub = function (x, y) {
        return BDDFunction.not(BDDFunction.add(BDDFunction.not(x), y));
    };
    BDDFunction.subus = function (x, y) {
        var timelimit = getmilitime() + 1000;
        var bits = new Int32Array(32);
        var borrow = 0;
        for (var i = 0; i < bits.length; i++) {
            bits[i] = bdd.xorxor(x._bits[i], y._bits[i], borrow, timelimit);
            borrow = bdd.carry(borrow, ~x._bits[i], y._bits[i]);
        }
        for (var i = 0; i < bits.length; i++)
            bits[i] = bdd.and(bits[i], ~borrow);
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.avg_up = function (x, y) {
        var timelimit = getmilitime() + 1000;
        var bits = new Int32Array(32);
        var carry = -1;
        for (var i = 0; i < bits.length; i++) {
            if (i >= 1)
                bits[i - 1] = bdd.xorxor(x._bits[i], y._bits[i], carry, timelimit);
            carry = bdd.carry(carry, x._bits[i], y._bits[i], timelimit);
        }
        bits[31] = carry;
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.abs = function (x) {
        var m = BDDFunction.nthbit(x, 31);
        return BDDFunction.xor(BDDFunction.add(x, m), m);
    };
    BDDFunction.bzhi = function (x, y) {
        y = BDDFunction.and(y, BDDFunction.constant(255));
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++) {
            var t = BDDFunction.le(y, BDDFunction.constant(i), false);
            bits[i] = bdd.and(~t._bits[0], x._bits[i]);
        }
        return new BDDFunction(bits, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.hor = function (x) {
        function insertionSort(array, cmp) {
            for (var i = 1; i < array.length; i++) {
                var j = i;
                while (j > 0 && cmp(array[j - 1], array[j]) > 0) {
                    var temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                    j = j - 1;
                }
            }
        }
        var bits = new Int32Array(x._bits);
        insertionSort(bits, function (a, b) {
            var va = bdd._v[a ^ (a >> 31)];
            var vb = bdd._v[b ^ (b >> 31)];
            return vb - va;
        });
        var or = 0;
        for (var i = 0; i < bits.length; i++) {
            if (i > 0 && bits[i] == bits[i - 1])
                continue;
            or = bdd.or(or, bits[i]);
        }
        for (var i = 0; i < bits.length; i++)
            bits[i] = or;
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.eqz = function (x) {
        var t = BDDFunction.hor(x);
        return ~t._bits[0];
    };
    BDDFunction.eq = function (x, y) {
        return BDDFunction.not(BDDFunction.hor(BDDFunction.xor(x, y)));
    };
    BDDFunction.lt = function (x, y, signed) {
        var borrow = new Int32Array(32);
        borrow[0] = bdd.and(~x._bits[0], y._bits[0]);
        for (var i = 1; i < 31; i++) {
            var xy = bdd.xor(~x._bits[i], y._bits[i]);
            borrow[i] = bdd.or(bdd.and(borrow[i - 1], xy), bdd.and(~x._bits[i], y._bits[i]));
        }
        if (signed) {
            var xy = bdd.xor(x._bits[31], ~y._bits[31]);
            borrow[31] = bdd.or(bdd.and(borrow[30], xy), bdd.and(x._bits[31], ~y._bits[31]));
        }
        else {
            var xy = bdd.xor(~x._bits[31], y._bits[31]);
            borrow[31] = bdd.or(bdd.and(borrow[30], xy), bdd.and(~x._bits[31], y._bits[31]));
        }
        var b = borrow[31];
        for (var i = 0; i < 32; i++)
            borrow[i] = b;
        return new BDDFunction(borrow, bdd.or(x._divideError, y._divideError));
    };
    BDDFunction.gt = function (x, y, signed) {
        return BDDFunction.lt(y, x, signed);
    };
    BDDFunction.ge = function (x, y, signed) {
        return BDDFunction.not(BDDFunction.lt(x, y, signed));
    };
    BDDFunction.le = function (x, y, signed) {
        return BDDFunction.not(BDDFunction.lt(y, x, signed));
    };
    BDDFunction.nthbit = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = x._bits[n];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.shlc = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = n; i < 32; i++)
            bits[i] = x._bits[i - n];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.shl = function (x, y) {
        for (var i = 0; i < 5; i++) {
            var mask = BDDFunction.nthbit(y, i);
            var s = BDDFunction.shlc(x, 1 << i);
            x = BDDFunction.mux(mask, x, s);
        }
        return x;
    };
    BDDFunction.shruc = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32 - n; i++)
            bits[i] = x._bits[i + n];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.shru = function (x, y) {
        for (var i = 0; i < 5; i++) {
            var mask = BDDFunction.nthbit(y, i);
            var s = BDDFunction.shruc(x, 1 << i);
            x = BDDFunction.mux(mask, x, s);
        }
        return x;
    };
    BDDFunction.shrsc = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = i + n < 32 ? x._bits[i + n] : x._bits[31];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.shrs = function (x, y) {
        for (var i = 0; i < 5; i++) {
            var mask = BDDFunction.nthbit(y, i);
            var s = BDDFunction.shrsc(x, 1 << i);
            x = BDDFunction.mux(mask, x, s);
        }
        return x;
    };
    BDDFunction.rolc = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = x._bits[i - n & 31];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.rorc = function (x, n) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = x._bits[i + n & 31];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.rol = function (x, y) {
        for (var i = 0; i < 5; i++) {
            var mask = BDDFunction.nthbit(y, i);
            var s = BDDFunction.rolc(x, 1 << i);
            x = BDDFunction.mux(mask, x, s);
        }
        return x;
    };
    BDDFunction.ror = function (x, y) {
        for (var i = 0; i < 5; i++) {
            var mask = BDDFunction.nthbit(y, i);
            var s = BDDFunction.rorc(x, 1 << i);
            x = BDDFunction.mux(mask, x, s);
        }
        return x;
    };
    BDDFunction.mul = function (x, y) {
        function countNonconstant(bits) {
            var count = 0;
            for (var i = 0; i < 32; i++) {
                if (bits[i] != 0 && bits[i] != -1)
                    count++;
            }
            return count;
        }
        if (countNonconstant(x._bits) * countNonconstant(y._bits) > 256)
            throw "multiplication seems hard";
        var r = BDDFunction.constant(0);
        for (var i = 0; i < 32; i++) {
            r = BDDFunction.add(r, BDDFunction.and(x, BDDFunction.nthbit(y, i)));
            x = BDDFunction.shlc(x, 1);
        }
        return r;
    };
    BDDFunction.clmul = function (x, y) {
        function countNonconstant(bits) {
            var count = 0;
            for (var i = 0; i < 32; i++) {
                if (bits[i] != 0 && bits[i] != -1)
                    count++;
            }
            return count;
        }
        if (countNonconstant(x._bits) * countNonconstant(y._bits) > 256)
            throw "multiplication seems hard";
        var r = BDDFunction.constant(0);
        for (var i = 0; i < 32; i++) {
            r = BDDFunction.xor(r, BDDFunction.and(x, BDDFunction.nthbit(y, i)));
            x = BDDFunction.shlc(x, 1);
        }
        return r;
    };
    BDDFunction.clpow = function (x, y) {
        var r = BDDFunction.constant(1);
        var one = BDDFunction.constant(1);
        for (var i = 0; i < 32; i++) {
            var ith = BDDFunction.nthbit(y, i);
            var p = BDDFunction.or(BDDFunction.and(x, ith), BDDFunction.and(one, BDDFunction.not(ith)));
            r = BDDFunction.clmul(r, p);
            x = BDDFunction.spread(x);
        }
        return r;
    };
    BDDFunction.ormul = function (x, y) {
        function countNonconstant(bits) {
            var count = 0;
            for (var i = 0; i < 32; i++) {
                if (bits[i] != 0 && bits[i] != -1)
                    count++;
            }
            return count;
        }
        if (countNonconstant(x._bits) * countNonconstant(y._bits) > 256)
            throw "multiplication seems hard";
        var r = BDDFunction.constant(0);
        for (var i = 0; i < 32; i++) {
            r = BDDFunction.or(r, BDDFunction.and(x, BDDFunction.nthbit(y, i)));
            x = BDDFunction.shlc(x, 1);
        }
        return r;
    };
    BDDFunction.ez80mlt = function (x) {
        var a = BDDFunction.and(x, BDDFunction.constant(0xFF));
        var b = BDDFunction.and(BDDFunction.shruc(x, 8), BDDFunction.constant(0xFF));
        return BDDFunction.mul(a, b);
    };
    BDDFunction.spread = function (x) {
        var bits = new Int32Array(32);
        for (var i = 0; i < bits.length; i += 2)
            bits[i] = x._bits[i >> 1];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.ctz = function (x) {
        x = BDDFunction.and(BDDFunction.not(x), BDDFunction.add(x, BDDFunction.constant(-1)));
        return BDDFunction.popcnt(x);
    };
    BDDFunction.clz = function (x) {
        x = BDDFunction.or(x, BDDFunction.shruc(x, 1));
        x = BDDFunction.or(x, BDDFunction.shruc(x, 2));
        x = BDDFunction.or(x, BDDFunction.shruc(x, 4));
        x = BDDFunction.or(x, BDDFunction.shruc(x, 8));
        x = BDDFunction.or(x, BDDFunction.shruc(x, 16));
        return BDDFunction.popcnt(BDDFunction.not(x));
    };
    BDDFunction.popcnt = function (x) {
        var timelimit = getmilitime() + 1000;
        var one = BDDFunction.constant(1);
        var r = BDDFunction.shruc(x, 31);
        for (var i = 30; i >= 0; i--) {
            r = BDDFunction.add(r, BDDFunction.and(BDDFunction.shruc(x, i), one));
            if (getmilitime() > timelimit)
                throw "BDD timeout";
        }
        return r;
    };
    BDDFunction.rbit = function (x) {
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = x._bits[i ^ 31];
        return new BDDFunction(bits, x._divideError);
    };
    BDDFunction.divu = function (a, b) {
        var diverror = bdd.or(BDDFunction.eqz(b), bdd.or(a._divideError, b._divideError));
        var P = new Int32Array(64);
        for (var i = 0; i < 32; i++)
            P[i] = a._bits[i];
        var D = new Int32Array(64);
        for (var i = 0; i < 32; i++)
            D[i + 32] = b._bits[i];
        var bits = new Int32Array(32);
        for (var i = 31; i >= 0; i--) {
            for (var j = P.length - 1; j > 0; j--)
                P[j] = P[j - 1];
            P[0] = 0;
            var borrow = new Int32Array(64);
            var newP = new Int32Array(64);
            for (var j = 0; j < P.length; j++) {
                var ab = bdd.xor(P[j], D[j]);
                newP[j] = ab;
                if (j > 0) {
                    newP[j] = bdd.xor(newP[j], borrow[j - 1]);
                    borrow[j] = bdd.or(bdd.and(~ab, borrow[j - 1]), bdd.and(~P[j], D[j]));
                }
                else
                    borrow[j] = bdd.and(~P[j], D[j]);
            }
            bits[i] = ~borrow[63];
            if (i != 0) {
                for (var j = 63; j > 0; j--)
                    P[j] = bdd.or(bdd.and(newP[j], ~borrow[63]), bdd.and(P[j], borrow[63]));
            }
        }
        return new BDDFunction(bits, diverror);
    };
    BDDFunction.divs = function (a, b) {
        var sign = BDDFunction.xor(BDDFunction.nthbit(a, 31), BDDFunction.nthbit(b, 31));
        var div = BDDFunction.divu(BDDFunction.abs(a), BDDFunction.abs(b));
        return BDDFunction.xor(sign, BDDFunction.add(sign, div));
    };
    BDDFunction.dive = function (a, b) {
        var sa = BDDFunction.nthbit(a, 31);
        var sb = BDDFunction.nthbit(b, 31);
        var div = BDDFunction.divu(BDDFunction.xor(a, sa), BDDFunction.abs(b));
        return BDDFunction.xor(sb, BDDFunction.add(sb, BDDFunction.xor(sa, div)));
    };
    BDDFunction.divupony = function (a, b) {
        var bnz = BDDFunction.hor(b);
        var az = BDDFunction.and(a, bnz);
        return new BDDFunction(BDDFunction.divu(az, BDDFunction.or(b, BDDFunction.not(bnz)))._bits, 0);
    };
    BDDFunction.remu = function (a, b) {
        var diverror = bdd.or(BDDFunction.eqz(b), bdd.or(a._divideError, b._divideError));
        var P = new Int32Array(64);
        for (var i = 0; i < 32; i++)
            P[i] = a._bits[i];
        var D = new Int32Array(64);
        for (var i = 0; i < 32; i++)
            D[i + 32] = b._bits[i];
        var bits = new Int32Array(32);
        for (var i = 31; i >= 0; i--) {
            for (var j = P.length - 1; j > 0; j--)
                P[j] = P[j - 1];
            P[0] = 0;
            var borrow = new Int32Array(64);
            var newP = new Int32Array(64);
            for (var j = 0; j < P.length; j++) {
                var ab = bdd.xor(P[j], D[j]);
                newP[j] = ab;
                if (j > 0) {
                    newP[j] = bdd.xor(newP[j], borrow[j - 1]);
                    borrow[j] = bdd.or(bdd.and(~ab, borrow[j - 1]), bdd.and(~P[j], D[j]));
                }
                else
                    borrow[j] = bdd.and(~P[j], D[j]);
            }
            for (var j = 63; j > 0; j--)
                P[j] = bdd.or(bdd.and(newP[j], ~borrow[63]), bdd.and(P[j], borrow[63]));
        }
        for (var i = 0; i < 32; i++)
            bits[i] = P[i + 32];
        return new BDDFunction(bits, diverror);
    };
    BDDFunction.rems = function (a, b) {
        var sign = BDDFunction.xor(BDDFunction.nthbit(a, 31), BDDFunction.nthbit(b, 31));
        var div = BDDFunction.remu(BDDFunction.abs(a), BDDFunction.abs(b));
        return BDDFunction.xor(sign, BDDFunction.add(sign, div));
    };
    BDDFunction.reme = function (a, b) {
        var sa = BDDFunction.nthbit(a, 31);
        b = BDDFunction.abs(b);
        var div = BDDFunction.remu(BDDFunction.xor(a, sa), b);
        return BDDFunction.add(BDDFunction.and(sa, b), BDDFunction.xor(sa, div));
    };
    function bdd_mul64(a, b, signed) {
        function countNonconstant(bits) {
            var count = 0;
            for (var i = 0; i < bits.length; i++) {
                if (bits[i] != 0 && bits[i] != -1)
                    count++;
            }
            return count;
        }
        if (countNonconstant(a) * countNonconstant(b) > 256)
            throw "multiplication seems hard";
        var c = new Int32Array(64);
        var a_sh = new Int32Array(64);
        for (var i = 0; i < 32; i++)
            a_sh[i] = a[i];
        for (var j = 0; j < 32; j++) {
            var m = b[j];
            if (m != 0) {
                var carry = 0;
                for (var i = 0; i < 64; i++) {
                    var am = bdd.and(m, a_sh[i]);
                    var nc = bdd.carry(am, c[i], carry);
                    c[i] = bdd.xorxor(am, c[i], carry);
                    carry = nc;
                }
            }
            for (var i = 63; i > 0; i--)
                a_sh[i] = a_sh[i - 1];
            a_sh[0] = 0;
        }
        if (signed) {
            var bfa = new BDDFunction(a, 0);
            var bfb = new BDDFunction(b, 0);
            var t1 = BDDFunction.and(bfa, BDDFunction.nthbit(bfb, 31));
            var t2 = BDDFunction.and(bfb, BDDFunction.nthbit(bfa, 31));
            var tophalf = new Int32Array(32);
            for (var i = 0; i < 32; i++)
                tophalf[i] = c[i + 32];
            var x = new BDDFunction(tophalf, 0);
            x = BDDFunction.sub(x, BDDFunction.add(t1, t2));
            for (var i = 0; i < 32; i++)
                c[i + 32] = x._bits[i];
        }
        return c;
    }
    ;
    BDDFunction.hmul = function (a, b, signed) {
        var prod = bdd_mul64(a._bits, b._bits, signed);
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = prod[i + 32];
        return new BDDFunction(bits, bdd.or(a._divideError, b._divideError));
    };
    BDDFunction.fixmul = function (a, b, q, signed) {
        // (64 bit)a * b >> q
        var prod = bdd_mul64(a._bits, b._bits, signed);
        var sh = 0;
        for (var i = 0; i < 5; i++) {
            if (q._bits[i] != 0 && q._bits[i] != -1)
                throw "fixed point math must have a fixed point";
            sh |= (1 << i) & q._bits[i];
        }
        var bits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            bits[i] = prod[i + sh];
        return new BDDFunction(bits, bdd.or(bdd.or(a._divideError, b._divideError), q._divideError));
    };
    BDDFunction.fixscale = function (a, x, y) {
        // (64 bit)a * x / y
        function div64_32(a, b) {
            var P = new Int32Array(128);
            for (var i = 0; i < 64; i++)
                P[i] = a[i];
            var D = new Int32Array(128);
            for (var i = 0; i < 32; i++)
                D[i + 64] = b[i];
            var bits = new Int32Array(64);
            for (var i = 63; i >= 0; i--) {
                for (var j = P.length - 1; j > 0; j--)
                    P[j] = P[j - 1];
                P[0] = 0;
                var borrow = new Int32Array(128);
                var newP = new Int32Array(128);
                for (var j = 0; j < P.length; j++) {
                    var ab = bdd.xor(P[j], D[j]);
                    newP[j] = ab;
                    if (j > 0) {
                        newP[j] = bdd.xor(newP[j], borrow[j - 1]);
                        borrow[j] = bdd.or(bdd.and(~ab, borrow[j - 1]), bdd.and(~P[j], D[j]));
                    }
                    else
                        borrow[j] = bdd.and(~P[j], D[j]);
                }
                bits[i] = ~borrow[127];
                if (i != 0) {
                    for (var j = 127; j > 0; j--)
                        P[j] = bdd.or(bdd.and(newP[j], ~borrow[127]), bdd.and(P[j], borrow[127]));
                }
            }
            var res = new Int32Array(32);
            for (var i = 0; i < 32; i++)
                res[i] = bits[i];
            return res;
        }
        var diverror = bdd.or(BDDFunction.eqz(y), bdd.or(a._divideError, bdd.or(x._divideError, y._divideError)));
        return new BDDFunction(div64_32(bdd_mul64(a._bits, x._bits, false), y._bits), diverror);
    };
    BDDFunction.fixlerp = function (a, b, x, y) {
        // (a * x + b * y) / (x + y)
        // c = a * x
        // d = b * y
        // e = x + y
        function fullmul(a, b) {
            var prod = new Int32Array(64);
            var c = new Int32Array(64);
            var a_sh = new Int32Array(64);
            for (var i = 0; i < 32; i++)
                a_sh[i] = a[i];
            for (var j = 0; j < 32; j++) {
                var m = b[j];
                if (m != 0) {
                    var carry = 0;
                    for (var i = 0; i < 64; i++) {
                        var am = bdd.and(m, a_sh[i]);
                        var nc = bdd.carry(am, c[i], carry);
                        c[i] = bdd.xorxor(am, c[i], carry);
                        carry = nc;
                    }
                }
                for (var i = 63; i > 0; i--)
                    a_sh[i] = a_sh[i - 1];
                a_sh[0] = 0;
            }
            return prod;
        }
        var c = fullmul(a._bits, x._bits);
        var d = fullmul(b._bits, y._bits);
        var e = new Int32Array(64);
    };
    BDDFunction.pdep = function (value, mask) {
        var res = BDDFunction.constant(0);
        for (var i = 0; i < 32; i++) {
            var lowest = BDDFunction.and(BDDFunction.sub(BDDFunction.constant(0), mask), mask);
            mask = BDDFunction.and(mask, BDDFunction.not(lowest));
            var vbit = BDDFunction.nthbit(value, i);
            res = BDDFunction.or(res, BDDFunction.and(lowest, vbit));
        }
        return res;
    };
    BDDFunction.pext = function (value, mask) {
        var res = BDDFunction.constant(0);
        for (var i = 0; i < 32; i++) {
            var lowest = BDDFunction.and(BDDFunction.sub(BDDFunction.constant(0), mask), mask);
            mask = BDDFunction.and(mask, BDDFunction.not(lowest));
            var spread = BDDFunction.hor(BDDFunction.and(lowest, value));
            var biti = BDDFunction.constant(1 << i);
            res = BDDFunction.or(res, BDDFunction.and(biti, spread));
        }
        return res;
    };
    BDDFunction.gf2affine = function (x, m1, m0) {
        function repbyte(x, k) {
            var t = BDDFunction.shruc(BDDFunction.shlc(x, k * 8), 24);
            t = BDDFunction.or(t, BDDFunction.shlc(t, 8));
            t = BDDFunction.or(t, BDDFunction.shlc(t, 16));
            return t;
        }
        var bytes = [];
        bytes.push(repbyte(m1, 0));
        bytes.push(repbyte(m1, 1));
        bytes.push(repbyte(m1, 2));
        bytes.push(repbyte(m1, 3));
        bytes.push(repbyte(m0, 0));
        bytes.push(repbyte(m0, 1));
        bytes.push(repbyte(m0, 2));
        bytes.push(repbyte(m0, 3));
        var res = BDDFunction.constant(0);
        var m = BDDFunction.constant(0x01010101);
        for (var i = 0; i < 8; i++) {
            var t = BDDFunction.and(x, bytes[i]);
            t = BDDFunction.xor(t, BDDFunction.shruc(t, 4));
            t = BDDFunction.xor(t, BDDFunction.shruc(t, 2));
            t = BDDFunction.xor(t, BDDFunction.shruc(t, 1));
            t = BDDFunction.and(t, m);
            res = BDDFunction.or(res, BDDFunction.shlc(t, i));
        }
        return res;
    };
    BDDFunction.quantU = function (f, q, varmap) {
        var bits = f._bits.slice();
        var de = f._divideError;
        for (var j = 0; j < q.length; j++) {
            var ql = varmap.indexOf(q[j]);
            var qh = ql;
            if (ql < 0)
                continue;
            while (j + 1 < q.length && varmap.indexOf(q[j + 1]) == qh + 1) {
                j++;
                qh++;
            }
            for (var i = 0; i < 32; i++)
                bits[i] = bdd.quantU(bits[i], ql, qh);
            de = bdd.quantU(de, ql, qh);
        }
        return new BDDFunction(bits, de);
    };
    BDDFunction.IdentifyPredicate = function (bit, negated) {
        // is of form (var & m) == c
        function isAndEqConst(x) {
            var m = 0, c = 0, vindex = -1;
            while (x != 0 && x != -1) {
                var inv = x >> 31;
                var v = bdd._v[x ^ inv];
                var lo = bdd._lo[x ^ inv] ^ inv;
                var hi = bdd._hi[x ^ inv] ^ inv;
                var vind = v & 63;
                if (vindex == -1)
                    vindex = vind;
                else if (vindex != vind)
                    return null;
                if (hi != 0 && lo != 0)
                    return null;
                var vbit = (v >> 6) ^ 31;
                m |= 1 << vbit;
                if (lo == 0) {
                    c |= 1 << vbit;
                    x = hi;
                }
                else
                    x = lo;
            }
            return [vindex, m, c];
        }
        var t = isAndEqConst(bit);
        if (t) {
            var x = new Variable(t[0]);
            if (t[1] != -1)
                x = new Binary(1, x, new Constant(t[1]));
            return new Binary(negated ? 21 : 20, x, new Constant(t[2]));
        }
        return null;
    };
    BDDFunction.prototype.AnalyzeTruth = function (data, root, vars, callback, debugcb) {
        bdd.reset();
        var res = data;
        var remap = new Array(2048);
        var index = 0;
        for (var i = 0; i < 32; i++) {
            for (var j = 0; j < vars.length; j++)
                if (data.quantified.indexOf(vars[j]) < 0)
                    remap[(i << 6) + j] = index++;
        }
        if (this._divideError == 0) {
            if (this._bits[0] == 0) {
                res.false = {
                    count: "#always"
                };
                if (root.type == 'bin' && root.op == 20 && vars.length > 0 && data.quantified.length == 0) {
                    res.false.ext_examples = true;
                    res.false.examples = function (ix) {
                        var len = vars.length;
                        var var_values = new Int32Array(len + 2);
                        for (var i = 0; i < 32; i++)
                            var_values[i % len] |= ((ix >>> i) & 1) << ~~(i / len);
                        var_values[len] = root.l.eval(var_values);
                        var_values[len + 1] = root.r.eval(var_values);
                        return var_values;
                    };
                }
            }
            else if (this._bits[0] == -1) {
                var resobj = {
                    count: "#always",
                    proof: undefined
                };
                if (root.type == 'bin' && root.op == 20 && data.quantified.length == 0) {
                    ProofFinder.proveAsync(root.l, root.r, function (flatproof) {
                        resobj.proof = flatproof;
                        callback();
                    }, debugcb);
                }
                res.true = resobj;
            }
            else {
                var bit0 = this._bits[0];
                res.true = {
                    count: bdd.satCount(bit0, index, remap).toString(),
                    examples: function (ix) {
                        return bdd.indexedSat(bit0, ix, index, remap);
                    }
                };
                var makeExamples = root.type == 'bin' && root.op == 20 && vars.length > 0 && data.quantified.length == 0;
                res.false = {
                    count: bdd.satCount(~bit0, index, remap).toString(),
                    ext_examples: makeExamples,
                    examples: function (ix) {
                        var values = bdd.indexedSat(~bit0, ix, index, remap);
                        if (!makeExamples)
                            return values;
                        if (!values)
                            return values;
                        var len = vars.length;
                        var res = new Int32Array(len + 2);
                        for (var i = 0; i < len; i++)
                            res[i] = values[i];
                        res[len] = root.l.eval(res);
                        res[len + 1] = root.r.eval(res);
                        return res;
                    }
                };
                if (this._bits.every(function (elem) { return elem == bit0; })) {
                    var p = BDDFunction.IdentifyPredicate(bit0, false) || BDDFunction.IdentifyPredicate(~bit0, true);
                    if (p)
                        res.true.pred = p;
                    var q = BDDFunction.IdentifyPredicate(~bit0, false) || BDDFunction.IdentifyPredicate(bit0, true);
                    if (q)
                        res.false.pred = q;
                }
            }
        }
        else if (this._divideError == -1) {
            res.diverror = {
                count: "#always"
            };
        }
        else {
            var de = this._divideError;
            res.diverror = {
                count: bdd.satCount(de, index, remap).toString(),
                examples: function (ix) {
                    return bdd.indexedSat(de, ix, index, remap);
                }
            };
            var trueNotError = bdd.and(this._bits[0], ~de);
            var falseNotError = bdd.and(~this._bits[0], ~de);
            if (trueNotError != 0) {
                res.true = {
                    count: bdd.satCount(trueNotError, index, remap).toString(),
                    examples: function (ix) {
                        return bdd.indexedSat(trueNotError, ix, index, remap);
                    }
                };
            }
            if (falseNotError != 0) {
                res.false = {
                    count: bdd.satCount(falseNotError, index, remap).toString(),
                    examples: function (ix) {
                        return bdd.indexedSat(falseNotError, ix, index, remap);
                    }
                };
            }
        }
        callback();
        return res;
    };
    BDDFunction.prototype.Identify = function (vars) {
        function isNicerConstant(x, y) {
            if (x == y)
                return false;
            if ((x & -x) == x || ((x + 1) & -(x + 1)) == (x + 1))
                return true;
            if (y >= -2 && y <= 15)
                return false;
            if (x >= -2 && x <= 15)
                return true;
            if (y < 0 && (-y & ~y) == 0 && -y <= 256)
                return false;
            if (x < 0 && (-x & ~x) == 0 && -x <= 256)
                return true;
            if (y <= 256 && y > 0 && ((y & y - 1) == 0 || (y + 1 & y) == 0))
                return false;
            if (x <= 256 && x > 0 && ((x & x - 1) == 0 || (x + 1 & x) == 0))
                return true;
            function numberOfLeadingZeros(a) {
                var i = 0;
                while (a != 0) {
                    i++;
                    a >>>= 1;
                }
                return 32 - i;
            }
            var x_leading = x < 0 ? numberOfLeadingZeros(-x) : numberOfLeadingZeros(x);
            var y_leading = y < 0 ? numberOfLeadingZeros(-y) : numberOfLeadingZeros(y);
            if (x_leading != y_leading)
                return x_leading > y_leading;
            var absx = x >> 31;
            absx = (x ^ absx) - absx;
            var absy = y >> 31;
            absy = (y ^ absy) - absy;
            return absx < absy;
        }
        function nicestConstant(v, and, or) {
            function bitCount(a) {
                a = a - ((a >>> 1) & 0x55555555);
                a = (a & 0x33333333) + ((a >>> 2) & 0x33333333);
                a = (a & 0x0f0f0f0f) + ((a >>> 4) & 0x0f0f0f0f);
                a = (a & 0x00ff00ff) + ((a >>> 8) & 0x00ff00ff);
                return (a & 0xff) + (a >>> 16);
            }
            function highestOneBit(a) {
                do {
                    var b = a & (a - 1);
                    if (b == 0)
                        return a;
                    a = b;
                } while (true);
            }
            var c = ~and | or;
            if (bitCount(c) < 10) {
                var best = v;
                for (var i = c & -c; i != 0; i = (i | ~c) + 1 & c) {
                    if (isNicerConstant(v ^ i, best))
                        best = v ^ i;
                }
                return best;
            }
            else {
                // try to make tiny constant
                var leastSet = v & ~c;
                if (leastSet >= 0 && leastSet <= 15)
                    return leastSet;
                var mostSet = v | c;
                if (mostSet >= -2 && mostSet <= 15)
                    return mostSet;
                // try to make small power of two
                if ((leastSet & leastSet - 1) == 0 && leastSet <= 256)
                    return leastSet;
                // try to make negative power of two
                var highestUnsettableZero = highestOneBit(~mostSet);
                var unsetMask = highestUnsettableZero - 1;
                var unset = unsetMask & (c | ~v); // must be unsettable and is either unsettable or already zero or both
                if (unsetMask == unset) {
                    var res = mostSet & ~unsetMask;
                    if ((res | c) != (v | c)) {
                        //debugger;
                        alert("something broke");
                    }
                    return res;
                }
                return leastSet;
            }
        }
        function is_constant(bits) {
            var value = 0;
            for (var i = 0; i < bits.length; i++) {
                if (bits[i] != 0 && bits[i] != -1)
                    return null;
                value |= (bits[i] & 1) << i;
            }
            return value;
        }
        // identify a function of the form
        // (OR[i = 0..n] (v[i] & a[i] ^ x[i])) & b | d
        function is_or(bits) {
            var a = new Int32Array(vars.length);
            var x = new Int32Array(vars.length);
            var b = 0;
            var d = 0;
            for (var i = 0; i < bits.length; i++) {
                var c = bits[i];
                if (c == 0)
                    continue;
                if (c == -1) {
                    d |= 1 << i;
                    continue;
                }
                // not a constant, so don't kill the bit
                b |= 1 << i;
                // walk the chain
                do {
                    var inv = c >> 31;
                    var v = bdd._v[c ^ inv];
                    var lo = bdd._lo[c ^ inv] ^ inv;
                    var hi = bdd._hi[c ^ inv] ^ inv;
                    // if the checked bit is not from the current bit index, it's not a nice bitwise function
                    if (((v >> 6) ^ 31) != i)
                        return null;
                    // otherwise, unkill the bit from this var
                    a[v & 63] |= 1 << i;
                    /* hi == -1: or with v[i]
                       lo == -1: or with ~v[i]
                     * lo ==  0: and with v[i]  // don't use this
                     * hi ==  0: and with ~v[i] // don't use this
                    */
                    if (hi == -1)
                        c = lo;
                    else if (lo == -1) {
                        x[v & 63] |= 1 << i;
                        c = hi;
                    }
                    else
                        return null;
                } while (c != 0 && c != -1);
            }
            return [a, x, b, d];
        }
        // identify a function of the form
        // (XOR[i] v[i] & a[i]) ^ x & b | d
        function is_xor(bits) {
            var a = new Int32Array(vars.length);
            var x = 0, b = 0, d = 0;
            for (var i = 0; i < bits.length; i++) {
                var c = bits[i];
                if (c == 0)
                    continue;
                if (c == -1) {
                    d |= 1 << i;
                    continue;
                }
                b |= 1 << i;
                do {
                    var inv = c >> 31;
                    var v = bdd._v[c ^ inv];
                    var lo = bdd._lo[c ^ inv] ^ inv;
                    var hi = bdd._hi[c ^ inv] ^ inv;
                    // if the checked bit is not from the current bit index, it's not a nice bitwise function
                    if (((v >> 6) ^ 31) != i)
                        return null;
                    a[v & 63] |= 1 << i;
                    /* hi == ~lo, xor with v[i]
                       otherwise: not an xor
                    */
                    if (hi == ~lo) {
                        x ^= 1 << i;
                        c = lo;
                        if (hi != 0)
                            x ^= 1 << i;
                    }
                    else
                        return null;
                } while (c != 0 && c != -1);
            }
            return [a, x, b, d];
        }
        function format_or(r_or) {
            var a = r_or[0];
            var x = r_or[1];
            var b = r_or[2];
            var d = r_or[3];
            var ignored = ~b | d;
            var used_vars = 0;
            var complemented_vars = 0;
            for (var i = 0; i < a.length; i++) {
                if (a[i] != 0)
                    used_vars++;
                if ((x[i] | ignored) == -1)
                    complemented_vars++;
            }
            // TODO: if the number of complemented vars is bigger than uncomplemented vars, format as ~and(stuff)
            //if (complemented_vars > used_vars - complemented_vars) {
            {
                var res = null;
                for (var i = 0; i < a.length; i++) {
                    if (a[i] == 0)
                        continue;
                    var v = new Variable(i);
                    if (a[i] != -1)
                        v = new Binary(ops.indexOf('&'), v, new Constant(a[i]));
                    if ((x[i] | ignored) == -1)
                        v = new Unary(0, v);
                    else if (x[i] != 0)
                        v = new Binary(ops.indexOf('^'), v, new Constant(nicestConstant(x[i], b, d)));
                    res = res ? new Binary(ops.indexOf('|'), res, v) : v;
                }
                if ((b | d) != -1 && a.length > 1)
                    res = new Binary(ops.indexOf('&'), res, new Constant(nicestConstant(b, -1, d)));
                if (d != 0)
                    res = new Binary(ops.indexOf('|'), res, new Constant(d));
                return res;
            }
        }
        function format_invor(r_or) {
            var a = r_or[0];
            var x = r_or[1];
            var b = r_or[2];
            var d = r_or[3];
            var ignored = ~b | d;
            // TODO: if the number of complemented vars is bigger than uncomplemented vars, format as ~and(stuff)
            //if (complemented_vars > used_vars - complemented_vars) {
            {
                var res = null;
                for (var i = 0; i < a.length; i++) {
                    if (a[i] == 0)
                        continue;
                    var v = new Variable(i);
                    if (a[i] != -1)
                        return null;
                    if ((x[i] | ignored) == -1)
                        v = v; // no inversion
                    else if ((x[i] & ~ignored) == 0)
                        v = new Unary(0, v);
                    else
                        v = new Binary(ops.indexOf('^'), v, new Constant(nicestConstant(~x[i], b, d)));
                    res = res ? new Binary(ops.indexOf('&'), res, v) : v;
                }
                if (~d != -1)
                    res = new Binary(ops.indexOf('&'), res, new Constant(~d));
                if ((~b & ~d) != 0)
                    res = new Binary(ops.indexOf('|'), res, new Constant(~b & ~d));
                return res;
            }
        }
        function format_xor(r_xor) {
            var a = r_xor[0];
            var x = r_xor[1];
            var b = r_xor[2];
            var d = r_xor[3];
            var ignored = ~b | d;
            var res = null;
            for (var i = 0; i < a.length; i++) {
                if (a[i] == 0)
                    continue;
                var v = new Variable(i);
                if ((a[i] | ignored) != -1)
                    v = new Binary(ops.indexOf('&'), v, new Constant(nicestConstant(a[i], b, d)));
                res = res ? new Binary(ops.indexOf('^'), res, v) : v;
            }
            if ((x & ~ignored) != 0)
                res = new Binary(ops.indexOf('^'), res, new Constant(nicestConstant(x, b, d)));
            if ((b | d) != -1)
                res = new Binary(ops.indexOf('&'), res, new Constant(nicestConstant(b, -1, d)));
            if (d != 0)
                res = new Binary(ops.indexOf('|'), res, new Constant(d));
            return res;
        }
        // identify a function of the form
        // v == c
        // returns: [v, c]
        function is_eqc(bits) {
            for (var i = 1; i < bits.length; i++)
                if (bits[0] != bits[i])
                    return null;
            var v = bdd._v[bits[0] ^ (bits[0] >> 31)] & 63;
            var c = 0;
            var x = bits[0];
            for (var i = 0; i < 32; i++) {
                if ((x ^ (x >> 31)) == 0)
                    return null;
                var inv = x >> 31;
                x ^= inv;
                var vv = bdd._v[x];
                if ((vv & 63) != v ||
                    (vv >> 6) != i)
                    return null;
                var lo = bdd._lo[x] ^ inv;
                var hi = bdd._hi[x] ^ inv;
                if (lo == 0 || hi == 0) {
                    if (lo == 0) {
                        x = hi;
                        c |= 1 << (i ^ 31);
                    }
                    else
                        x = lo;
                }
                else
                    return null;
            }
            return [v, c];
        }
        // identify a function of the form
        // pdep(v, c1) ^ c2
        // return: [v, c1, c2]
        function is_pdepc(bits) {
            var lastindex = -1, v = -1, c1 = 0, c2 = 0;
            for (var i = 0; i < bits.length; i++) {
                var x = bits[i];
                if (x == 0)
                    continue;
                if (x == -1) {
                    c2 |= 1 << i;
                    continue;
                }
                var inv = x >> 31;
                x ^= inv;
                if (v == -1)
                    v = bdd._v[x] & 63;
                else if (v != (bdd._v[x] & 63))
                    return null;
                var index = (bdd._v[x] >> 6) ^ 31;
                if (index != lastindex + 1)
                    return null;
                else {
                    c1 |= 1 << i;
                    lastindex = index;
                }
                var lo = bdd._lo[x] ^ inv;
                var hi = bdd._hi[x] ^ inv;
                if (lo == -1 && hi == 0)
                    c2 |= 1 << i;
                else if (lo != 0 || hi != -1)
                    return null;
            }
            if (lastindex < 0 || v < 0)
                return null;
            return [v, c1, c2];
        }
        function format_pdepc(r_pdep) {
            var node = new Binary(ops.indexOf('$pdep'), new Variable(r_pdep[0]), new Constant(r_pdep[1]));
            if (r_pdep[2] != 0)
                node = new Binary(3, node, new Constant(r_pdep[2]));
            return node;
        }
        // identify a function of the form
        // (x >>> c1) & c2
        // return: [x, c1, c2]
        function is_ror(bits) {
            var mask = 0, v = -1, c1 = -1;
            for (var i = 0; i < bits.length; i++) {
                var x = bits[i];
                if (x == 0)
                    continue;
                if (x == -1)
                    return null;
                mask |= 1 << i;
                var inv = x >> 31;
                x ^= inv;
                if (v == -1)
                    v = bdd._v[x] & 63;
                else if (v != (bdd._v[x] & 63))
                    return null;
                if (c1 == -1)
                    c1 = (bdd._v[x] >> 6) + i & 31;
                else if (c1 != ((bdd._v[x] >> 6) + i & 31))
                    return null;
                var lo = bdd._lo[x] ^ inv;
                var hi = bdd._hi[x] ^ inv;
                if (lo != 0 || hi != -1)
                    return null;
            }
            if (v < 0 || c1 < 0)
                return null;
            return [v, c1 ^ 31, mask];
        }
        function format_ror(r_ror) {
            if (clz(r_ror[2]) >= r_ror[1]) {
                // all upper bits that get "rotated in" are dropped
                var node = new Binary(31, new Variable(r_ror[0]), new Constant(r_ror[1]));
                if (r_ror[2] != (-1 >>> r_ror[1]))
                    node = new Binary(1, node, new Constant(r_ror[2]));
                return node;
            }
            var node = new Binary(9, new Variable(r_ror[0]), new Constant(r_ror[1]));
            if (r_ror[2] != -1)
                node = new Binary(1, node, new Constant(r_ror[2]));
            return node;
        }
        if (this._divideError != 0)
            return null;
        var r_constant = is_constant(this._bits);
        if (r_constant != null) {
            return new Constant(r_constant);
        }
        var r_or = is_or(this._bits);
        if (r_or)
            return format_or(r_or);
        var r_xor = is_xor(this._bits);
        if (r_xor)
            return format_xor(r_xor);
        var r_eqc = is_eqc(this._bits);
        if (r_eqc) {
            return new Binary(ops.indexOf('=='), new Variable(r_eqc[0]), new Constant(r_eqc[1]));
        }
        var r_pdep = is_pdepc(this._bits);
        if (r_pdep)
            return format_pdepc(r_pdep);
        var r_ror = is_ror(this._bits);
        if (r_ror)
            return format_ror(r_ror);
        var invbits = new Int32Array(32);
        for (var i = 0; i < 32; i++)
            invbits[i] = ~this._bits[i];
        r_or = is_or(invbits);
        if (r_or)
            return format_invor(r_or);
    };
    BDDFunction.prototype.AnalyzeProperties = function (data, vars, root, callback) {
        function getLowestUnsigned(res, bits, mustBeZero, maxvar, remap) {
            try {
                var bitsCombined = -1;
                var val = 0;
                for (var i = 31; i >= 0; i--) {
                    var tryZero = bdd.and(bitsCombined, ~bits[i]);
                    if (tryZero != 0) {
                        bitsCombined = tryZero;
                        continue;
                    }
                    var tryOne = bdd.and(bitsCombined, bits[i]);
                    if (tryOne != 0) {
                        bitsCombined = tryOne;
                        val |= 1 << i;
                        continue;
                    }
                    // unreachable
                    //debugger;
                }
                // only use it if not trivial
                if (val != 0 && val - 1 && val != ~mustBeZero) {
                    res.lowestUnsigned = {
                        value: val,
                        count: bdd.satCount(bitsCombined, maxvar, remap).toString(),
                        examples: function (ix) {
                            return bdd.indexedSat(bitsCombined, ix, maxvar, remap);
                        }
                    };
                    return true;
                }
                return false;
            }
            catch (ex) {
                //debugger;
            }
        }
        function getHighestUnsigned(res, bits, mustBeOne, maxvar, remap) {
            try {
                var bitsCombined = -1;
                var val = 0;
                for (var i = 31; i >= 0; i--) {
                    var tryOne = bdd.and(bitsCombined, bits[i]);
                    if (tryOne != 0) {
                        bitsCombined = tryOne;
                        val |= 1 << i;
                        continue;
                    }
                    var tryZero = bdd.and(bitsCombined, ~bits[i]);
                    if (tryZero != 0) {
                        bitsCombined = tryZero;
                        continue;
                    }
                    // unreachable
                    //debugger;
                }
                // only use it if not trivial
                if (val != -1 && val != 0 && val != mustBeOne) {
                    res.highestUnsigned = {
                        value: val,
                        count: bdd.satCount(bitsCombined, maxvar, remap).toString(),
                        examples: function (ix) {
                            return bdd.indexedSat(bitsCombined, ix, maxvar, remap);
                        }
                    };
                    return true;
                }
                return false;
            }
            catch (ex) {
                //debugger;
            }
        }
        function isBijection(bits) {
            try {
                var v0 = BDDFunction.argument(0);
                var v1 = BDDFunction.argument(1);
                var eq01 = BDDFunction.eq(v0, v1);
                var t = getmilitime() + 200;
                var xorself = bits.map(function (x) {
                    return bdd.xor(x, bdd.incv(x, 1), t);
                });
                var iseq = BDDFunction.eq(new BDDFunction(xorself, 0), BDDFunction.constant(0));
                return bdd.andIsZero(iseq._bits[0], ~eq01._bits[0]);
            }
            catch (err) {
                return null;
            }
        }
        function swapVar01(x, t) {
            var invert = x >> 31;
            x ^= invert;
            if (x == 0)
                return x ^ invert;
            var hash = x % 1048573;
            if (bdd._memoop[hash] == 0x55 && bdd._memokey1[hash] == x)
                return bdd._memo[hash] ^ invert;
            if (getmilitime() >= t)
                throw new "BDD timeout";
            var xv = bdd._v[x];
            var xlo = bdd._lo[x];
            var xhi = bdd._hi[x];
            var lo = swapVar01(xlo, t);
            var hi = swapVar01(xhi, t);
            var plainvar = bdd.mk(xv ^ 1, 0, -1);
            var value = bdd.mux(plainvar, lo, hi);
            bdd._memoop[hash] = 0x55;
            bdd._memokey1[hash] = x;
            bdd._memo[hash] = value;
            return value ^ invert;
        }
        function isCommutative(bits) {
            try {
                var t = getmilitime() + 200;
                var swapped = bits.map(function (x) {
                    return swapVar01(x, t);
                });
                return swapped.every(function (x, i) { return x == bits[i]; });
            }
            catch (err) {
                return null;
            }
        }
        if (!data.properties)
            data.properties = {};
        var res = data.properties;
        // "constant bit" masks
        var mustBeZero = 0;
        var mustBeOne = 0;
        for (var i = 0; i < 32; i++) {
            if (this._bits[i] == -1)
                mustBeOne |= 1 << i;
            else if (this._bits[i] == 0)
                mustBeZero |= 1 << i;
        }
        // if it's completely constant, properties will be uninteresting
        if ((mustBeOne | mustBeZero) == -1)
            return null;
        // try to find nibble mask
        if ((mustBeOne | mustBeZero) != 0) {
            var nibmask = "0x";
            for (var i = 28; i >= 0; i -= 4) {
                var isconst = mustBeZero | mustBeOne;
                if (((isconst >> i) & 15) == 15)
                    nibmask += ((mustBeOne >> i) & 15).toString(16);
                else if (((isconst >> i) & 15) == 0)
                    nibmask += '*';
                else {
                    nibmask = null;
                    break;
                }
            }
            // if no nibmask is possible or if it's all wildcards anyway, don't use it
            if (nibmask != null && nibmask != "0x********") {
                res.nibmask = nibmask;
            }
        }
        if (nibmask == null && (mustBeOne | mustBeZero) != 0) {
            // find bitmask
            var bitmask = "";
            for (var i = 31; i >= 0; i--) {
                if ((mustBeZero & (1 << i)) != 0)
                    bitmask += '0';
                else if ((mustBeOne & (1 << i)) != 0)
                    bitmask += '1';
                else
                    bitmask += '*';
            }
            res.bitmask = bitmask;
        }
        var remap = new Array(2048);
        var index = 0;
        for (var i = 0; i < 32; i++) {
            for (var j = 0; j < vars.length; j++)
                remap[(i << 6) + j] = index++;
        }
        getLowestUnsigned(res, this._bits, mustBeZero, index, remap);
        getHighestUnsigned(res, this._bits, mustBeOne, index, remap);
        if (callback)
            callback();
        function replaceVars(root) {
            switch (root.type) {
                case "var": return new Variable(root.index ^ 1);
                case "const": return root;
                case "un": return new Unary(root.op, replaceVars(root.value));
                case "bin": return new Binary(root.op, replaceVars(root.l), replaceVars(root.r));
                case "assoc": return new Assoc(root.op, root.operands.map(replaceVars));
                case "ter": return new Ternary(replaceVars(root.cond), replaceVars(root.t), replaceVars(root.f));
                case "fun": return new Function(root.fun, root.args.map(replaceVars));
                default: alert("missing case in bddfunction.replaceVars");
            }
        }
        if (vars.length == 1 && !res.inverse && (mustBeOne | mustBeZero) == 0) {
            var bij = isBijection(this._bits);
            if (bij != null) {
                res.invertible = bij;
                var feq = new Binary(20, root, replaceVars(root));
                var veq = new Binary(20, new Variable(0), new Variable(1));
                res.inverseproof = new Binary(ops.indexOf("=>"), feq, veq).print(["x", "y"]);
                if (callback)
                    callback();
            }
        }
        if (vars.length == 2) {
            var comm = isCommutative(this._bits);
            if (comm != null) {
                res.commutative = comm;
                res.commutativeproof = new Binary(20, root, replaceVars(root)).print(vars);
                if (callback)
                    callback();
            }
        }
        return res;
    };
    // END - bddfunction
    // START - prooffinder
    var ops = [, "&", "|", "^", "+", "-", "<<", ">>", "<<<", ">>>", "/", "*", "/e", "%e", "/p", , , , , , "==", "!=", "<=", "<", ">=", ">", "=>", "&&", "||", , ">>s", ">>u", "/s", "/u", "%s", "%u", , , , , "<=s", "<=u", "<s", "<u", ">=s", ">=u", ">s", ">u", "$bzhi", "$subus", "$pdep", "$pext", "$avg_up", "$addus", , "$min_u", "$min_s", "$max_u", "$max_s", "$hmul_u", "$hmul_s", "$clmul", "$clpow", "$ormul"];
    var unops = ["~", "-", "$popcnt", "$ntz", "$nlz", "$reverse", "$abs", "$ez80mlt", "$blsi", "$blsr", "$blsmsk", "$tzmsk"];
    var commutative = [, true, true, true, true, false, false, false, false, false, false, true, false, false, false, , , , , , true, true, false, false, false, false, false, true, true, , false, false, false, false, false, false, , , , , false, false, false, false, false, false, false, false, false, false, false, false, true, true, , true, true, true, true, true, true, true, false, true];
    var associative = [, true, true, true, true, false, false, false, false, false, false, true, false, false, false, , , , , , false, false, false, false, false, false, false, true, true, , false, false, false, false, false, false, , , , , false, false, false, false, false, false, false, false, false, false, true, false, false, false, , true, true, true, true, false, false, true, false, true];
    function mayThrow(index) {
        return index == 10 || (index >= 12 && index <= 14) || (index >= 32 && index <= 35);
    }
    function ProofFinder(op, assocmode) {
        var except_not = 1;
        var except_neg = 2;
        var except_zero = 3;
        var except_unknown_or_zero = 4;
        var except_non_mersenne = 5;
        this.dead = op != 20;
        this.assocmode = assocmode;
        function a(x) {
            return {
                any: x
            };
        }
        function aex(x, ex) {
            return {
                any: x,
                except: ex
            };
        }
        var rules = [
            /*
                rules, format
                [expr from, expr to, mirror, description1, description2?]
                expressions here are arrays [op, args..] or [var/const]
            */
            // properties of and
            [
                ["&", [a(0)], [0]],
                [0],
                false, "and with 0", ,
            ],
            [
                ["&", [0], [a(0)]],
                [0],
                false, "and with 0", ,
            ],
            [
                ["&", [a(0)], [-1]],
                [a(0)],
                false, "and with -1", ,
            ],
            [
                ["&", [-1], [a(0)]],
                [a(0)],
                false, "and with -1", ,
            ],
            [
                ["&", [a(0)], [a(0)]],
                [a(0)],
                false, "and with self", ,
            ],
            [
                ["&", [a(0)], ["~", [a(0)]]],
                [0],
                false, "and with complement of self", ,
            ],
            [
                ["&", ["~", [a(0)]], [a(0)]],
                [0],
                false, "and with complement of self", ,
            ],
            [
                ["&", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", [a(0)], ["&", [a(1)], [a(2)]]],
                true, "associativity of and", ,
            ],
            [
                ["&", [a(0)], [a(1)]],
                ["&", [a(1)], [a(0)]],
                false, "commutativity of and", ,
            ],
            // properties of or
            [
                ["|", [a(0)], [0]],
                [a(0)],
                false, "or with 0", ,
            ],
            [
                ["|", [0], [a(0)]],
                [a(0)],
                false, "or with 0", ,
            ],
            [
                ["|", [a(0)], [-1]],
                [-1],
                false, "or with -1", ,
            ],
            [
                ["|", [-1], [a(0)]],
                [-1],
                false, "or with -1", ,
            ],
            [
                ["|", [a(0)], [a(0)]],
                [a(0)],
                false, "or with self", ,
            ],
            [
                ["|", [a(0)], ["~", [a(0)]]],
                [-1],
                false, "or with complement of self", ,
            ],
            [
                ["|", ["~", [a(0)]], [a(0)]],
                [-1],
                false, "or with complement of self", ,
            ],
            [
                ["|", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", [a(0)], ["|", [a(1)], [a(2)]]],
                true, "associativity of or", ,
            ],
            [
                ["|", [a(0)], [a(1)]],
                ["|", [a(1)], [a(0)]],
                false, "commutativity of or", ,
            ],
            [
                ["|", ["^", [a(0)], [a(1)]], [a(1)]],
                ["|", [a(0)], [a(1)]],
                false, "changed bits are masked", ,
            ],
            [
                ["|", ["&", [a(0)], [a(1)]], ["&", [a(0)], ["~", [a(1)]]]],
                [a(0)],
                false, "union of complementary subsets", ,
            ],
            // properties of xor
            [
                ["^", [a(0)], [0]],
                [a(0)],
                false, "xor with 0", ,
            ],
            [
                ["^", [0], [a(0)]],
                [a(0)],
                false, "xor with 0", ,
            ],
            [
                ["^", [a(0)], [-1]],
                ["~", [a(0)]],
                false, "xor with -1", ,
            ],
            [
                ["^", [-1], [a(0)]],
                ["~", [a(0)]],
                false, "xor with -1", ,
            ],
            [
                ["^", [a(0)], [a(0)]],
                [0],
                false, "xor with self", ,
            ],
            [
                ["^", [a(0)], ["~", [a(0)]]],
                [-1],
                false, "xor with complement of self", ,
            ],
            [
                ["^", ["~", [a(0)]], [a(0)]],
                [-1],
                false, "xor with complement of self", ,
            ],
            [
                ["^", [a(0)], [a(1)]],
                ["|", ["&", [a(0)], ["~", [a(1)]]], ["&", ["~", [a(0)]], [a(1)]]],
                true, "definition #1 of xor", ,
            ],
            [
                ["|", ["&", ["~", [a(0)]], [a(1)]], ["&", [a(0)], ["~", [a(1)]]]],
                ["^", [a(0)], [a(1)]],
                false, "definition #1 of xor", ,
            ],
            [
                ["^", [a(0)], [a(1)]],
                ["&", ["|", [a(0)], [a(1)]], ["|", ["~", [a(0)]], ["~", [a(1)]]]],
                true, "definition #2 of xor", ,
            ],
            [
                ["&", ["|", ["~", [a(0)]], ["~", [a(1)]]], ["|", [a(0)], [a(1)]]],
                ["^", [a(0)], [a(1)]],
                false, "definition #2 of xor", ,
            ],
            [
                ["^", [a(0)], [a(1)]],
                ["&", ["|", [a(0)], [a(1)]], ["~", ["&", [a(0)], [a(1)]]]],
                true, "definition #3 of xor", ,
            ],
            [
                ["&", ["~", ["&", [a(0)], [a(1)]]], ["|", [a(0)], [a(1)]]],
                ["^", [a(0)], [a(1)]],
                false, "definition #3 of xor", ,
            ],
            [
                ["^", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", [a(0)], ["^", [a(1)], [a(2)]]],
                true, "associativity of xor", ,
            ],
            [
                ["^", [a(0)], [a(1)]],
                ["^", [a(1)], [a(0)]],
                false, "commutativity of xor", ,
            ],
            [
                ["^", ["~", [a(0)]], [a(1)]],
                ["~", ["^", [a(0)], [a(1)]]],
                true, "move complement out of xor", "move complement into xor",
            ],
            [
                ["^", [a(0)], ["~", [a(1)]]],
                ["~", ["^", [a(0)], [a(1)]]],
                true, "move complement out of xor", "move complement into xor",
            ],
            [
                ["^", ["~", [a(0)]], ["~", [a(1)]]],
                ["^", [aex(0, except_not)], [aex(1, except_not)]],
                true, "double complement in xor", ,
            ],
            [
                ["^", ["~", [a(0)]], [a(1)]],
                ["^", [a(0)], ["~", [a(1)]]],
                true, "move complement", ,
            ],
            [
                ["^", ["&", [a(0)], [a(1)]], ["&", [a(0)], ["~", [a(1)]]]],
                [a(0)],
                false, "xor of complementary subsets", ,
            ],
            // properties of addition
            [
                ["+", [a(0)], [0]],
                [a(0)],
                false, "additive identity", ,
            ],
            [
                ["+", [0], [a(0)]],
                [a(0)],
                false, "additive identity", ,
            ],
            [
                ["+", [a(0)], ["~", [a(0)]]],
                [-1],
                false, "add to complement of self", ,
            ],
            [
                ["+", ["~", [a(0)]], [a(0)]],
                [-1],
                false, "add to complement of self", ,
            ],
            [
                ["+", [a(0)], ["-", [a(0)]]],
                [0],
                false, "add to negation of self", ,
            ],
            [
                ["+", ["-", [a(0)]], [a(0)]],
                [0],
                false, "add to negation of self", ,
            ],
            [
                ["&", ["+", [a(0)], [a(1)]], [aex(2, except_non_mersenne)]],
                ["&", ["+", ["&", [a(0)], [aex(2, except_non_mersenne)]], ["&", [a(1)], [aex(2, except_non_mersenne)]]], [aex(2, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: z is a power of two minus one)", ,
            ],
            [
                ["&", ["+", ["&", [a(0)], [aex(1, except_non_mersenne)]], ["&", [a(2)], [aex(1, except_non_mersenne)]]], [aex(1, except_non_mersenne)]],
                ["&", ["+", [a(0)], [a(2)]], [aex(1, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: y is a power of two minus one)", ,
            ],
            [
                ["+", ["+", [a(0)], [a(1)]], [a(2)]],
                ["+", [a(0)], ["+", [a(1)], [a(2)]]],
                true, "associativity of addition", ,
            ],
            [
                ["+", [a(0)], [a(1)]],
                ["+", [a(1)], [a(0)]],
                false, "commutativity of addition", ,
            ],
            [
                ["+", ["&", [a(0)], [a(1)]], ["&", [a(0)], ["~", [a(1)]]]],
                [a(0)],
                false, "addition of complementary subsets", ,
            ],
            [
                ["+", ["<<", ["&", [a(0)], [a(1)]], [1]], ["^", [a(0)], [a(1)]]],
                ["+", [a(0)], [a(1)]],
                false, "combine single-bit sums with carries", "split into single-bit sums and carries",
            ],
            // properties of subtraction
            [
                ["-", [a(0)], [0]],
                [a(0)],
                false, "subtract zero", ,
            ],
            [
                ["-", [-1], [a(0)]],
                ["~", [a(0)]],
                false, "subtract from -1 is complement", ,
            ],
            [
                ["-", [a(0)], [a(0)]],
                [0],
                false, "subtract from self", ,
            ],
            [
                ["-", [a(0)]],
                ["-", [0], [a(0)]],
                true, "definition of negation", ,
            ],
            [
                ["-", [aex(0, except_zero)], [a(1)]],
                ["-", ["-", [a(1)], [a(0)]]],
                true, "anticommutativity of subtraction", ,
            ],
            [
                ["&", ["-", [a(0)], [a(1)]], [aex(2, except_non_mersenne)]],
                ["&", ["-", ["&", [a(0)], [aex(2, except_non_mersenne)]], ["&", [a(1)], [aex(2, except_non_mersenne)]]], [aex(2, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: z is a power of two minus one)", ,
            ],
            [
                ["&", ["-", ["&", [a(0)], [aex(1, except_non_mersenne)]], ["&", [a(2)], [aex(1, except_non_mersenne)]]], [aex(1, except_non_mersenne)]],
                ["&", ["-", [a(0)], [a(2)]], [aex(1, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: y is a power of two minus one)", ,
            ],
            [
                ["&", ["-", ["&", [a(0)], [aex(1, except_non_mersenne)]]], [aex(1, except_non_mersenne)]],
                ["&", ["-", [a(0)]], [a(1)]],
                false, "low bits of the result depend only on low bits of the input (condition: y is a power of two minus one)", ,
            ],
            // properties of rbit
            [
                ["$reverse", ["$reverse", [a(0)]]],
                [a(0)],
                false, "double reverse", ,
            ],
            // properties of mux
            [
                ["?", [0], [a(0)], [a(1)]],
                [a(1)],
                false, "mux with 0", ,
            ],
            [
                ["?", [-1], [a(0)], [a(1)]],
                [a(0)],
                false, "mux with -1", ,
            ],
            [
                ["?", ["~", [a(0)]], [a(1)], [a(2)]],
                ["?", [a(0)], [a(2)], [a(1)]],
                false, "swap arguments of mux", ,
            ],
            [
                ["?", [a(0)], [a(0)], ["~", [a(0)]]],
                [-1],
                false, "mux between something and its complement", ,
            ],
            [
                ["?", [a(0)], ["~", [a(0)]], [a(0)]],
                [0],
                false, "mux between something and its complement", ,
            ],
            [
                ["?", [a(0)], [a(1)], ["?", [a(0)], [a(2)], [a(3)]]],
                ["?", [a(0)], [a(1)], [a(3)]],
                false, "the same condition must have the same value in both uses", ,
            ],
            [
                ["?", [a(0)], ["?", [a(0)], [a(1)], [a(2)]], [a(3)]],
                ["?", [a(0)], [a(1)], [a(3)]],
                false, "the same condition must have the same value in both uses", ,
            ],
            [
                ["?", [a(0)], [a(1)], [a(2)]],
                ["|", ["&", [a(0)], [a(1)]], ["&", ["~", [a(0)]], [a(2)]]],
                true, "definition of mux", ,
            ],
            [
                ["?", [a(0)], [a(1)], [a(2)]],
                ["|", ["&", [a(0)], [a(1)]], ["&", [a(2)], ["~", [a(0)]]]],
                true, "definition of mux", ,
            ],
            [
                ["|", ["&", ["~", [a(0)]], [a(1)]], ["&", [a(0)], [a(2)]]],
                ["?", [a(0)], [a(2)], [a(1)]],
                false, "definition of mux", ,
            ],
            // properties of min_u
            [
                ["$min_u", [a(0)], [0]],
                [0],
                false, "zero is the smallest unsigned number", ,
            ],
            [
                ["$min_u", [a(0)], [-1]],
                [a(0)],
                false, "-1 is the highest unsigned number", ,
            ],
            [
                ["$min_u", [a(0)], [a(0)]],
                [a(0)],
                false, "minimum with self", ,
            ],
            [
                ["$min_u", [a(0)], ["$min_u", [a(1)], [a(2)]]],
                ["$min_u", ["$min_u", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of minimum", ,
            ],
            [
                ["$min_u", [a(0)], [a(1)]],
                ["$min_u", [a(1)], [a(0)]],
                false, "commutativity of minimum", ,
            ],
            [
                ["$min_u", [a(0)], [a(1)]],
                ["?", ["<u", [a(0)], [a(1)]], [a(0)], [a(1)]],
                true, "definition of minimum", ,
            ],
            [
                ["$min_u", [a(0)], [a(1)]],
                ["?", [">u", [a(0)], [a(1)]], [a(1)], [a(0)]],
                true, "definition of minimum", ,
            ],
            // properties of min_s
            [
                ["$min_s", [a(0)], [0x80000000]],
                [0x80000000],
                false, "min_s with the smallest signed number", ,
            ],
            [
                ["$min_s", [a(0)], [0x7fffffff]],
                [a(0)],
                false, "min_s with the highest signed number", ,
            ],
            [
                ["$min_s", [a(0)], [a(0)]],
                [a(0)],
                false, "minimum with self", ,
            ],
            [
                ["$min_s", [a(0)], ["$min_s", [a(1)], [a(2)]]],
                ["$min_s", ["$min_s", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of minimum", ,
            ],
            [
                ["$min_s", [a(0)], [a(1)]],
                ["$min_s", [a(1)], [a(0)]],
                false, "commutativity of minimum", ,
            ],
            [
                ["$min_s", [a(0)], [a(1)]],
                ["?", ["<s", [a(0)], [a(1)]], [a(0)], [a(1)]],
                true, "definition of minimum", ,
            ],
            [
                ["$min_s", [a(0)], [a(1)]],
                ["?", [">s", [a(0)], [a(1)]], [a(1)], [a(0)]],
                true, "definition of minimum", ,
            ],
            // properties of max_u
            [
                ["$max_u", [a(0)], [0]],
                [a(0)],
                false, "zero is the smallest unsigned number", ,
            ],
            [
                ["$max_u", [a(0)], [-1]],
                [-1],
                false, "-1 is the highest unsigned number", ,
            ],
            [
                ["$max_u", [a(0)], [a(0)]],
                [a(0)],
                false, "maximum with self", ,
            ],
            [
                ["$max_u", [a(0)], ["$max_u", [a(1)], [a(2)]]],
                ["$max_u", ["$max_u", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of maximum", ,
            ],
            [
                ["$max_u", [a(0)], [a(1)]],
                ["$max_u", [a(1)], [a(0)]],
                false, "commutativity of maximum", ,
            ],
            [
                ["$max_u", [a(0)], [a(1)]],
                ["?", [">u", [a(0)], [a(1)]], [a(0)], [a(1)]],
                true, "definition of maximum", ,
            ],
            [
                ["$max_u", [a(0)], [a(1)]],
                ["?", ["<u", [a(0)], [a(1)]], [a(1)], [a(0)]],
                true, "definition of maximum", ,
            ],
            // properties of max_s
            [
                ["$max_s", [a(0)], [0x80000000]],
                [a(0)],
                false, "max_s with the smallest signed number", ,
            ],
            [
                ["$max_s", [a(0)], [0x7fffffff]],
                [0x7fffffff],
                false, "max_s with the highest signed number", ,
            ],
            [
                ["$max_s", [a(0)], [a(0)]],
                [a(0)],
                false, "maximum with self", ,
            ],
            [
                ["$max_s", [a(0)], ["$max_s", [a(1)], [a(2)]]],
                ["$max_s", ["$max_s", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of maximum", ,
            ],
            [
                ["$max_s", [a(0)], [a(1)]],
                ["$max_s", [a(1)], [a(0)]],
                false, "commutativity of maximum", ,
            ],
            [
                ["$max_s", [a(0)], [a(1)]],
                ["?", [">s", [a(0)], [a(1)]], [a(0)], [a(1)]],
                true, "definition of maximum", ,
            ],
            [
                ["$max_s", [a(0)], [a(1)]],
                ["?", ["<s", [a(0)], [a(1)]], [a(1)], [a(0)]],
                true, "definition of maximum", ,
            ],
            // properties of left shift
            [
                ["<<", [a(0)], [0]],
                [a(0)],
                false, "shift by zero", ,
            ],
            [
                ["<<", [0], [a(0)]],
                [0],
                false, "shifting zero", ,
            ],
            [
                ["<<", [a(0)], [1]],
                ["+", [a(0)], [a(0)]],
                false, "shift by one is *2", ,
            ],
            [
                ["<<", [a(0)], [1]],
                ["*", [a(0)], [2]],
                false, "shift by one is *2", ,
            ],
            // properties of right shift
            [
                [">>u", [a(0)], [0]],
                [a(0)],
                false, "shift by zero", ,
            ],
            [
                [">>u", [0], [a(0)]],
                [0],
                false, "shifting zero", ,
            ],
            // properties of arithmetic right shift
            [
                [">>s", [a(0)], [0]],
                [a(0)],
                false, "shift by zero", ,
            ],
            [
                [">>s", [0], [a(0)]],
                [0],
                false, "shifting zero", ,
            ],
            // properties of multiplication
            [
                ["*", ["*", [a(0)], [a(1)]], [a(2)]],
                ["*", [a(0)], ["*", [a(1)], [a(2)]]],
                true, "associativity of multiplication", ,
            ],
            [
                ["*", [a(0)], [a(1)]],
                ["*", [a(1)], [a(0)]],
                false, "commutativity of multiplication", ,
            ],
            [
                ["*", [a(0)], [1]],
                [a(0)],
                false, "multiplicative identity", ,
            ],
            [
                ["*", [1], [a(0)]],
                [a(0)],
                false, "multiplicative identity", ,
            ],
            [
                ["*", [a(0)], [-1]],
                ["-", [a(0)]],
                false, "multiplication by minus one", ,
            ],
            [
                ["+", ["*", [a(0)], [a(1)]], [a(0)]],
                ["*", [a(0)], ["+", [a(1)], [1]]],
                false, "special case of distributivity", ,
            ],
            [
                ["&", ["*", [a(0)], [a(1)]], [aex(2, except_non_mersenne)]],
                ["&", ["*", ["&", [a(0)], [aex(2, except_non_mersenne)]], ["&", [a(1)], [aex(2, except_non_mersenne)]]], [aex(2, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: z is a power of two minus one)", ,
            ],
            [
                ["&", ["*", ["&", [a(0)], [aex(1, except_non_mersenne)]], ["&", [a(2)], [aex(1, except_non_mersenne)]]], [aex(1, except_non_mersenne)]],
                ["&", ["*", [a(0)], [a(2)]], [aex(1, except_non_mersenne)]],
                false, "low bits of the result depend only on low bits of the inputs (condition: y is a power of two minus one)", ,
            ],
            // properties of clmul
            [
                ["$clmul", ["$clmul", [a(0)], [a(1)]], [a(2)]],
                ["$clmul", [a(0)], ["$clmul", [a(1)], [a(2)]]],
                true, "associativity of carryless multiplication", ,
            ],
            [
                ["$clmul", [a(0)], [a(1)]],
                ["$clmul", [a(1)], [a(0)]],
                false, "commutativity of carryless multiplication", ,
            ],
            [
                ["$clmul", [a(0)], [1]],
                [a(0)],
                false, "multiplicative identity", ,
            ],
            [
                ["$clmul", [1], [a(0)]],
                [a(0)],
                false, "multiplicative identity", ,
            ],
            // properties of reverse
            [
                ["$reverse", ["$reverse", [a(0)]]],
                [a(0)],
                false, "double reverse cancels", ,
            ],
            // properties of nlz
            [
                ["$nlz", [a(0)]],
                ["&", ["$nlz", [a(0)]], [0x3F]],
                true, "nlz only goes up to 32, so the top bits are always zero", ,
            ],
            // properties of ntz
            [
                ["$ntz", [a(0)]],
                ["&", ["$ntz", [a(0)]], [0x3F]],
                true, "ntz only goes up to 32, so the top bits are always zero", ,
            ],
            // properties of popcnt
            [
                ["$popcnt", [a(0)]],
                ["&", ["$popcnt", [a(0)]], [0x3F]],
                true, "popcnt only goes up to 32, so the top bits are always zero", ,
            ],
            [
                ["$popcnt", ["~", [a(0)]]],
                ["-", [32], ["$popcnt", [a(0)]]],
                true, "count the bits that are zero", ,
            ],
            [
                ["+", ["$popcnt", [a(0)]], ["$popcnt", ["~", [a(0)]]]],
                [32],
                false, "the number of ones plus the number of zeroes is all bits", ,
            ],
            // properties of subus
            [
                ["$subus", [a(0)], [a(1)]],
                ["&", ["-", [a(0)], [a(1)]], [">u", [a(0)], [a(1)]]],
                true, "definition of subtraction with unsigned saturation", ,
            ],
            [
                ["$subus", [a(0)], [a(1)]],
                ["?", [">u", [a(0)], [a(1)]], ["-", [a(0)], [a(1)]], [0]],
                true, "definition of subtraction with unsigned saturation", ,
            ],
            [
                ["$subus", [a(0)], [a(1)]],
                ["-", ["+", ["$subus", [a(1)], [a(0)]], [a(0)]], [a(1)]],
                false, "compensated commutativity of saturating subtraction", ,
            ],
            [
                ["-", ["+", ["$subus", [a(0)], [a(1)]], [a(1)]], [a(0)]],
                ["$subus", [a(1)], [a(0)]],
                false, "compensated commutativity of saturating subtraction", ,
            ],
            // properties of addus
            [
                ["$addus", [a(0)], [0]],
                [a(0)],
                false, "additive identity", ,
            ],
            [
                ["$addus", [a(0)], [a(1)]],
                ["$addus", [a(1)], [a(0)]],
                false, "commutativity of addition with unsigned saturation", ,
            ],
            [
                ["$addus", ["$addus", [a(0)], [a(1)]], [a(2)]],
                ["$addus", [a(0)], ["$addus", [a(1)], [a(2)]]],
                true, "associativity of addition with unsigned saturation", ,
            ],
            [
                ["$addus", [a(0)], [a(1)]],
                ["|", ["+", [a(0)], [a(1)]], ["<u", ["+", [a(0)], [a(1)]], [a(0)]]],
                true, "definition of addition with unsigned saturation", ,
            ],
            [
                ["$addus", [a(0)], [a(1)]],
                ["|", ["+", [a(0)], [a(1)]], ["<u", ["+", [a(0)], [a(1)]], [a(1)]]],
                true, "definition of addition with unsigned saturation", ,
            ],
            [
                ["$subus", [a(0)], [a(1)]],
                ["~", ["$addus", ["~", [a(0)]], [a(1)]]],
                true, "unsigned-saturating version of a - b == ~(~a + b)", ,
            ],
            // properties of BMI stuff
            [
                ["$blsi", [a(0)]],
                ["&", [a(0)], ["-", [a(0)]]],
                true, "definition of blsi", ,
            ],
            [
                ["$blsr", [a(0)]],
                ["&", [a(0)], ["-", [a(0)], [1]]],
                true, "definition of blsr", ,
            ],
            [
                ["$blsmsk", [a(0)]],
                ["^", [a(0)], ["-", [a(0)], [1]]],
                true, "definition of blsmsk", ,
            ],
            [
                ["$tzmsk", [a(0)]],
                ["&", ["~", [a(0)]], ["-", [a(0)], [1]]],
                true, "definition of tzmsk #1", ,
            ],
            [
                ["$tzmsk", [a(0)]],
                ["-", ["&", [a(0)], ["-", [a(0)]]], [1]],
                true, "definition of tzmsk #2", ,
            ],
            [
                ["$tzmsk", [a(0)]],
                ["-", ["&", ["-", [a(0)]], [a(0)]], [1]],
                true, "definition of tzmsk #2", ,
            ],
            [
                ["$blsi", ["$blsi", [a(0)]]],
                ["$blsi", [a(0)]],
                false, "blsi is idempotent", ,
            ],
            [
                ["$blsr", ["$blsi", [a(0)]]],
                [0],
                false, "blsi leaves at most a single bit set", ,
            ],
            [
                ["&", ["$popcnt", ["$blsi", [a(0)]]], [1]],
                ["$popcnt", ["$blsi", [a(0)]]],
                false, "blsi leaves at most a single bit set", ,
            ],
            [
                ["$blsmsk", ["$blsmsk", [a(0)]]],
                [1],
                false, "blsmsk always has an odd result", ,
            ],
            [
                ["&", ["$blsmsk", [a(0)]], [1]],
                [1],
                false, "blsmsk always has an odd result", ,
            ],
            [
                ["|", ["$blsmsk", [a(0)]], [1]],
                ["$blsmsk", [a(0)]],
                false, "blsmsk always has an odd result", ,
            ],
            [
                ["&", ["$blsr", [a(0)]], [1]],
                [0],
                false, "blsr always has an even result", ,
            ],
            [
                ["&", ["$blsr", [a(0)]], [-2]],
                ["$blsr", [a(0)]],
                false, "blsr always has an even result", ,
            ],
            [
                ["$popcnt", ["$tzmsk", [a(0)]]],
                ["$ntz", [a(0)]],
                false, "counting the trailing zeroes", ,
            ],
            [
                ["&", [a(0)], ["~", ["$blsi", [a(0)]]]],
                ["$blsr", [a(0)]],
                false, "resetting lowest set bit", ,
            ],
            [
                ["&", [a(0)], ["~", ["$blsi", [a(0)]]]],
                ["$blsr", [a(0)]],
                false, "resetting lowest set bit", ,
            ],
            [
                ["^", [a(0)], ["$blsi", [a(0)]]],
                ["$blsr", [a(0)]],
                false, "resetting lowest set bit", ,
            ],
            [
                ["-", [a(0)], ["$blsi", [a(0)]]],
                ["$blsr", [a(0)]],
                false, "resetting lowest set bit", ,
            ],
            // properties of ==
            [
                ["==", [a(0)], [a(0)]],
                [-1],
                false, "equality is reflexive", ,
            ],
            [
                ["==", [a(0)], ["~", [a(0)]]],
                [0],
                false, "nothing is equal to its complement", ,
            ],
            [
                ["==", ["~", [a(0)]], [a(0)]],
                [0],
                false, "nothing is equal to its complement", ,
            ],
            [
                ["==", [a(0)], ["^", [a(0)], [aex(1, except_unknown_or_zero)]]],
                [0],
                false, "some bits changed, so unequal", ,
            ],
            [
                ["==", ["^", [a(0)], [aex(1, except_unknown_or_zero)]], [a(0)]],
                [0],
                false, "some bits changed, so unequal", ,
            ],
            [
                ["==", [a(0)], ["+", [a(0)], [aex(1, except_unknown_or_zero)]]],
                [0],
                false, "adding a non-zero amount changes the value", ,
            ],
            [
                ["==", ["+", [a(0)], [aex(1, except_unknown_or_zero)]], [a(0)]],
                [0],
                false, "adding a non-zero amount changes the value", ,
            ],
            [
                ["==", ["^", [a(0)], [a(1)]], [a(2)]],
                ["==", [a(1)], ["^", [a(2)], [a(0)]]],
                false, "xor with x on both sides", ,
            ],
            [
                ["==", ["^", [a(0)], [a(1)]], [a(2)]],
                ["==", [a(0)], ["^", [a(2)], [a(1)]]],
                false, "xor with y on both sides", ,
            ],
            [
                ["==", [a(0)], ["^", [a(1)], [a(2)]]],
                ["==", ["^", [a(0)], [a(1)]], [a(2)]],
                false, "xor with y on both sides", ,
            ],
            [
                ["==", [a(0)], ["^", [a(1)], [a(2)]]],
                ["==", ["^", [a(0)], [a(2)]], [a(1)]],
                false, "xor with z on both sides", ,
            ],
            [
                ["==", ["$popcnt", [a(0)]], [0]],
                ["==", [a(0)], [0]],
                false, "only 0 has no bits set", ,
            ],
            [
                ["==", ["$popcnt", [a(0)]], [32]],
                ["==", [a(0)], [-1]],
                false, "only -1 has all bits set", ,
            ],
            [
                ["==", ["$nlz", [a(0)]], [32]],
                ["==", [a(0)], [0]],
                false, "only 0 has 32 leading zeroes", ,
            ],
            [
                ["==", ["$ntz", [a(0)]], [32]],
                ["==", [a(0)], [0]],
                false, "only 0 has 32 trailing zeroes", ,
            ],
            [
                ["==", [a(0)], [a(1)]],
                ["==", [a(1)], [a(0)]],
                false, "commutativity of equality", ,
            ],
            // properties of <s
            [
                ["<s", [a(0)], [0]],
                [">>s", [a(0)], [31]],
                true, "numbers are negative iff the top bit is set", ,
            ],
            // properties of bzhi
            [
                ["$bzhi", [a(0)], [0]],
                [0],
                false, "zero all bits", ,
            ],
            [
                ["$bzhi", [a(0)], [32]],
                [a(0)],
                false, "zero no bits", ,
            ],
            [
                ["$bzhi", ["$bzhi", [a(0)], [a(1)]], [a(1)]],
                ["$bzhi", [a(0)], [a(1)]],
                false, "multiple bzhi with the same index", ,
            ],
            // properties of pdep
            [
                ["$pdep", [a(0)], [0]],
                [0],
                false, "empty mask", ,
            ],
            [
                ["$pdep", [a(0)], [-1]],
                [a(0)],
                false, "pdep with full mask", ,
            ],
            [
                ["$pdep", [-1], [a(0)]],
                [a(0)],
                false, "pdep left-identity", ,
            ],
            [
                ["$pdep", [a(0)], [aex(1, except_non_mersenne)]],
                ["&", [a(0)], [a(1)]],
                false, "contiguous mask", ,
            ],
            [
                ["$pdep", [a(0)], ["$pdep", [a(1)], [a(2)]]],
                ["$pdep", ["$pdep", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of pdep", ,
            ],
            [
                ["$pdep", [a(0)], ["<<", [a(1)], [a(2)]]],
                ["<<", ["$pdep", [a(0)], [a(1)]], [a(2)]],
                true, "move shift out of pdep", "move shift into pdep",
            ],
            // properties of pext
            [
                ["$pext", [a(0)], [0]],
                [0],
                false, "empty mask", ,
            ],
            [
                ["$pext", [a(0)], [aex(1, except_non_mersenne)]],
                ["&", [a(0)], [a(1)]],
                false, "contiguous mask", ,
            ],
            // division stuff
            [
                ["/u", [a(0)], [1]],
                [a(0)],
                false, "division by 1", ,
            ],
            [
                ["/s", [a(0)], [1]],
                [a(0)],
                false, "division by 1", ,
            ],
            [
                ["/e", [a(0)], [1]],
                [a(0)],
                false, "division by 1", ,
            ],
            [
                ["%e", [a(0)], ["-", [a(1)]]],
                ["%e", [a(0)], [a(1)]],
                false, "Euclidean remainder ignores sign of divisor", ,
            ],
            [
                ["%e", [a(0)], ["$abs", [a(1)]]],
                ["%e", [a(0)], [a(1)]],
                false, "Euclidean remainder ignores sign of divisor", ,
            ],
            [
                ["/e", [a(0)], ["-", [a(1)]]],
                ["-", ["/e", [a(0)], [a(1)]]],
                true, "move negation out of division", "move negation into division",
            ],
            [
                ["/e", [a(0)], [a(1, except_unknown_or_zero)]],
                ["-", ["/e", [a(0)], ["-", [a(1)]]]],
                false, "move negation out of division", ,
            ],
            [
                ["+", ["*", [a(0, except_unknown_or_zero)], ["/u", [a(1)], [a(0, except_unknown_or_zero)]]], ["%u", [a(1)], [a(0, except_unknown_or_zero)]]],
                [a(1)],
                false, "division rule", ,
            ],
            [
                ["+", ["*", [a(0, except_unknown_or_zero)], ["/s", [a(1)], [a(0, except_unknown_or_zero)]]], ["%s", [a(1)], [a(0, except_unknown_or_zero)]]],
                [a(1)],
                false, "division rule", ,
            ],
            [
                ["+", ["*", [a(0, except_unknown_or_zero)], ["/e", [a(1)], [a(0, except_unknown_or_zero)]]], ["%e", [a(1)], [a(0, except_unknown_or_zero)]]],
                [a(1)],
                false, "division rule", ,
            ],
            // interrelations between operations
            // absorption
            [
                ["&", [a(0)], ["|", [a(0)], [a(1)]]],
                [a(0)],
                false, "and cancels or (absorption law)", ,
            ],
            [
                ["|", [a(0)], ["&", [a(0)], [a(1)]]],
                [a(0)],
                false, "or cancels and (absorption law)", ,
            ],
            // De Morgan
            [
                ["~", ["&", [a(0)], [a(1)]]],
                ["|", ["~", [a(0)]], ["~", [a(1)]]],
                true, "De Morgan's law", ,
            ],
            [
                ["~", ["|", [a(0)], [a(1)]]],
                ["&", ["~", [a(0)]], ["~", [a(1)]]],
                true, "De Morgan's law", ,
            ],
            // double operation
            [
                ["~", ["~", [a(0)]]],
                [aex(0, except_not)],
                false, "double complement", ,
            ],
            [
                ["-", ["-", [a(0)]]],
                [aex(0, except_neg)],
                false, "double negation", ,
            ],
            [
                ["$abs", ["$abs", [a(0)]]],
                ["$abs", [a(0)]],
                false, "abs is idempotent", ,
            ],
            // carryless square move
            [
                ["^", ["$clmul", [a(0)], [a(0)]], ["$clmul", [a(1)], [a(1)]]],
                ["$clmul", ["^", [a(0)], [a(1)]], ["^", [a(0)], [a(1)]]],
                true, "move XOR into carryless square", "move XOR out of carryless square",
            ],
            [
                ["&", ["$clmul", [a(0)], [a(0)]], ["$clmul", [a(1)], [a(1)]]],
                ["$clmul", ["&", [a(0)], [a(1)]], ["&", [a(0)], [a(1)]]],
                true, "move AND into carryless square", "move AND out of carryless square",
            ],
            [
                ["|", ["$clmul", [a(0)], [a(0)]], ["$clmul", [a(1)], [a(1)]]],
                ["$clmul", ["|", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                true, "move OR into carryless square", "move OR out of carryless square",
            ],
            [
                ["^", ["$clmul", [a(0)], [a(0)]], ["$clmul", [a(1)], [a(1)]]],
                ["$clmul", ["^", [a(0)], [a(1)]], ["^", [a(0)], [a(1)]]],
                true, "move XOR into carryless square", "move XOR out of carryless square",
            ],
            [
                ["$reverse", ["$clmul", [a(0)], [a(0)]]],
                ["$clmul", ["$reverse", [a(0)]], ["$reverse", [a(0)]]],
                true, "move reverse into carryless square", "move reverse out of carryless square",
            ],
            // double shift
            [
                ["<<", [">>u", [a(0)], [a(1)]], [a(1)]],
                ["&", [a(0)], ["-", ["<<", [1], [a(1)]]]],
                true, "truncate rightmost bits", ,
            ],
            [
                ["<<", [">>s", [a(0)], [a(1)]], [a(1)]],
                ["&", [a(0)], ["-", ["<<", [1], [a(1)]]]],
                true, "truncate rightmost bits", ,
            ],
            // distributivity pairs
            [
                ["-", ["+", [a(0)], [a(1)]]],
                ["-", ["-", [a(0)]], [a(1)]],
                true, "negation distributes over addition", ,
            ],
            [
                ["&", [a(0)], ["|", [a(1)], [a(2)]]],
                ["|", ["&", [a(0)], [a(1)]], ["&", [a(0)], [a(2)]]],
                true, "and distributes over or", ,
            ],
            [
                ["|", ["&", [a(0)], [a(1)]], ["&", [a(2)], [a(1)]]],
                ["&", ["|", [a(0)], [a(2)]], [a(1)]],
                true, "and distributes over or", ,
            ],
            [
                ["&", [a(0)], ["^", [a(1)], [a(2)]]],
                ["^", ["&", [a(0)], [a(1)]], ["&", [a(0)], [a(2)]]],
                true, "and distributes over xor", ,
            ],
            [
                ["^", ["&", [a(0)], [a(1)]], ["&", [a(2)], [a(1)]]],
                ["&", ["^", [a(0)], [a(2)]], [a(1)]],
                true, "and distributes over xor", ,
            ],
            [
                ["|", [a(0)], ["&", [a(1)], [a(2)]]],
                ["&", ["|", [a(0)], [a(1)]], ["|", [a(0)], [a(2)]]],
                true, "or distributes over and", ,
            ],
            [
                ["&", ["|", [a(0)], [a(1)]], ["|", [a(2)], [a(1)]]],
                ["|", ["&", [a(0)], [a(2)]], [a(1)]],
                true, "or distributes over and", ,
            ],
            [
                ["*", [a(0)], ["+", [a(1)], [a(2)]]],
                ["+", ["*", [a(0)], [a(1)]], ["*", [a(0)], [a(2)]]],
                true, "multiplication distributes over addition", ,
            ],
            [
                ["+", ["*", [a(0)], [a(1)]], ["*", [a(2)], [a(1)]]],
                ["*", ["+", [a(0)], [a(2)]], [a(1)]],
                true, "multiplication distributes over addition", ,
            ],
            [
                ["*", [a(0)], ["-", [a(1)], [a(2)]]],
                ["-", ["*", [a(0)], [a(1)]], ["*", [a(0)], [a(2)]]],
                true, "multiplication distributes over subtraction", ,
            ],
            [
                ["-", ["*", [a(0)], [a(1)]], ["*", [a(2)], [a(1)]]],
                ["*", ["-", [a(0)], [a(2)]], [a(1)]],
                true, "multiplication distributes over subtraction", ,
            ],
            [
                ["$max_u", [a(0)], ["$min_u", [a(1)], [a(2)]]],
                ["$min_u", ["$max_u", [a(0)], [a(1)]], ["$max_u", [a(0)], [a(2)]]],
                true, "maximum distributes over minimum", ,
            ],
            [
                ["$min_u", ["$max_u", [a(0)], [a(1)]], ["$max_u", [a(2)], [a(1)]]],
                ["$max_u", ["$min_u", [a(0)], [a(2)]], [a(1)]],
                true, "maximum distributes over minimum", ,
            ],
            [
                ["$max_s", [a(0)], ["$min_s", [a(1)], [a(2)]]],
                ["$min_s", ["$max_s", [a(0)], [a(1)]], ["$max_s", [a(0)], [a(2)]]],
                true, "maximum distributes over minimum", ,
            ],
            [
                ["$min_s", ["$max_s", [a(0)], [a(1)]], ["$max_s", [a(2)], [a(1)]]],
                ["$max_s", ["$min_s", [a(0)], [a(2)]], [a(1)]],
                true, "maximum distributes over minimum", ,
            ],
            [
                ["&", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                ["$reverse", ["&", [a(0)], [a(1)]]],
                true, "reverse distributes over and"
            ],
            [
                ["^", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                ["$reverse", ["^", [a(0)], [a(1)]]],
                true, "reverse distributes over xor"
            ],
            [
                ["|", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                ["$reverse", ["|", [a(0)], [a(1)]]],
                true, "reverse distributes over or"
            ],
            [
                ["$pdep", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", ["$pdep", [a(0)], [a(2)]], ["$pdep", [a(1)], [a(2)]]],
                false, "pdep distributes over and"
            ],
            [
                ["&", ["$pdep", [a(0)], [a(1)]], ["$pdep", [a(2)], [a(1)]]],
                ["$pdep", ["&", [a(0)], [a(2)]], [a(1)]],
                false, "pdep distributes over and"
            ],
            [
                ["$pdep", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", ["$pdep", [a(0)], [a(2)]], ["$pdep", [a(1)], [a(2)]]],
                false, "pdep distributes over or"
            ],
            [
                ["|", ["$pdep", [a(0)], [a(1)]], ["$pdep", [a(2)], [a(1)]]],
                ["$pdep", ["|", [a(0)], [a(2)]], [a(1)]],
                false, "pdep distributes over or"
            ],
            [
                ["$pdep", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", ["$pdep", [a(0)], [a(2)]], ["$pdep", [a(1)], [a(2)]]],
                false, "pdep distributes over xor"
            ],
            [
                ["^", ["$pdep", [a(0)], [a(1)]], ["$pdep", [a(2)], [a(1)]]],
                ["$pdep", ["^", [a(0)], [a(2)]], [a(1)]],
                false, "pdep distributes over xor"
            ],
            [
                ["$pdep", ["+", [a(0)], [a(1)]], [a(2)]],
                ["&", ["+", ["|", ["$pdep", [a(0)], [a(2)]], ["~", [a(2)]]], ["$pdep", [a(1)], [a(2)]]], [a(2)]],
                false, "move addition out of pdep"
            ],
            // shifts over or
            [
                ["<<", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", ["<<", [a(0)], [a(2)]], ["<<", [a(1)], [a(2)]]],
                false, "left shift distributes over or", ,
            ],
            [
                ["|", ["<<", [a(0)], [a(1)]], ["<<", [a(2)], [a(1)]]],
                ["<<", ["|", [a(0)], [a(2)]], [a(1)]],
                false, "left shift distributes over or", ,
            ],
            [
                [">>u", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", [">>u", [a(0)], [a(2)]], [">>u", [a(1)], [a(2)]]],
                false, "right shift distributes over or", ,
            ],
            [
                ["|", [">>u", [a(0)], [a(1)]], [">>u", [a(2)], [a(1)]]],
                [">>u", ["|", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over or", ,
            ],
            [
                [">>s", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", [">>s", [a(0)], [a(2)]], [">>s", [a(1)], [a(2)]]],
                false, "right shift distributes over or", ,
            ],
            [
                ["|", [">>s", [a(0)], [a(1)]], [">>s", [a(2)], [a(1)]]],
                [">>s", ["|", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over or", ,
            ],
            // shifts over and
            [
                ["<<", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", ["<<", [a(0)], [a(2)]], ["<<", [a(1)], [a(2)]]],
                false, "left shift distributes over and", ,
            ],
            [
                ["&", ["<<", [a(0)], [a(1)]], ["<<", [a(2)], [a(1)]]],
                ["<<", ["&", [a(0)], [a(2)]], [a(1)]],
                false, "left shift distributes over and", ,
            ],
            [
                [">>u", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", [">>u", [a(0)], [a(2)]], [">>u", [a(1)], [a(2)]]],
                false, "right shift distributes over and", ,
            ],
            [
                ["&", [">>u", [a(0)], [a(1)]], [">>u", [a(2)], [a(1)]]],
                [">>u", ["&", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over and", ,
            ],
            [
                [">>s", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", [">>s", [a(0)], [a(2)]], [">>s", [a(1)], [a(2)]]],
                false, "right shift distributes over and", ,
            ],
            [
                ["&", [">>s", [a(0)], [a(1)]], [">>s", [a(2)], [a(1)]]],
                [">>s", ["&", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over and", ,
            ],
            // shifts over xor
            [
                ["<<", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", ["<<", [a(0)], [a(2)]], ["<<", [a(1)], [a(2)]]],
                false, "left shift distributes over xor", ,
            ],
            [
                ["^", ["<<", [a(0)], [a(1)]], ["<<", [a(2)], [a(1)]]],
                ["<<", ["^", [a(0)], [a(2)]], [a(1)]],
                false, "left shift distributes over xor", ,
            ],
            [
                [">>u", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", [">>u", [a(0)], [a(2)]], [">>u", [a(1)], [a(2)]]],
                false, "right shift distributes over xor", ,
            ],
            [
                ["^", [">>u", [a(0)], [a(1)]], [">>u", [a(2)], [a(1)]]],
                [">>u", ["^", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over xor", ,
            ],
            [
                [">>s", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", [">>s", [a(0)], [a(2)]], [">>s", [a(1)], [a(2)]]],
                false, "right shift distributes over xor", ,
            ],
            [
                ["^", [">>s", [a(0)], [a(1)]], [">>s", [a(2)], [a(1)]]],
                [">>s", ["^", [a(0)], [a(2)]], [a(1)]],
                false, "right shift distributes over xor", ,
            ],
            // bitwise operations distribute over mux
            [
                ["~", ["?", [a(0)], [a(1)], [a(2)]]],
                ["?", [a(0)], ["~", [a(1)]], ["~", [a(2)]]],
                true, "complement distributes over mux", ,
            ],
            [
                ["&", ["?", [a(0)], [a(1)], [a(2)]], [a(3)]],
                ["?", [a(0)], ["&", [a(1)], [a(3)]], ["&", [a(2)], [a(3)]]],
                true, "and distributes over mux", ,
            ],
            [
                ["|", ["?", [a(0)], [a(1)], [a(2)]], [a(3)]],
                ["?", [a(0)], ["|", [a(1)], [a(3)]], ["|", [a(2)], [a(3)]]],
                true, "or distributes over mux", ,
            ],
            [
                ["^", ["?", [a(0)], [a(1)], [a(2)]], [a(3)]],
                ["?", [a(0)], ["^", [a(1)], [a(3)]], ["^", [a(2)], [a(3)]]],
                true, "xor distributes over mux", ,
            ],
            [
                ["$reverse", ["?", [a(0)], [a(1)], [a(2)]]],
                ["?", ["$reverse", [a(0)]], ["$reverse", [a(1)]], ["$reverse", [a(2)]]],
                true, "reverse distributes over mux", ,
            ],
            // reverse distributes over all bitwise operations
            [
                ["$reverse", ["&", [a(0)], [a(1)]]],
                ["&", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                true, "reverse distributes over and", ,
            ],
            [
                ["$reverse", ["|", [a(0)], [a(1)]]],
                ["|", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                true, "reverse distributes over or", ,
            ],
            [
                ["$reverse", ["^", [a(0)], [a(1)]]],
                ["^", ["$reverse", [a(0)]], ["$reverse", [a(1)]]],
                true, "reverse distributes over xor", ,
            ],
            // bzhi distributes over some stuff
            [
                ["$bzhi", ["|", [a(0)], [a(1)]], [a(2)]],
                ["|", ["$bzhi", [a(0)], [a(2)]], ["$bzhi", [a(1)], [a(2)]]],
                true, "bzhi right-distributes over or", ,
            ],
            [
                ["|", ["$bzhi", [a(0)], [a(1)]], ["$bzhi", [a(2)], [a(1)]]],
                ["$bzhi", ["|", [a(0)], [a(2)]], [a(1)]],
                true, "bzhi right-distributes over or", ,
            ],
            [
                ["$bzhi", ["^", [a(0)], [a(1)]], [a(2)]],
                ["^", ["$bzhi", [a(0)], [a(2)]], ["$bzhi", [a(1)], [a(2)]]],
                true, "bzhi right-distributes over xor", ,
            ],
            [
                ["^", ["$bzhi", [a(0)], [a(1)]], ["$bzhi", [a(2)], [a(1)]]],
                ["$bzhi", ["^", [a(0)], [a(2)]], [a(1)]],
                true, "bzhi right-distributes over xor", ,
            ],
            [
                ["$bzhi", ["&", [a(0)], [a(1)]], [a(2)]],
                ["&", ["$bzhi", [a(0)], [a(2)]], ["$bzhi", [a(1)], [a(2)]]],
                true, "bzhi right-distributes over and", ,
            ],
            [
                ["&", ["$bzhi", [a(0)], [a(1)]], ["$bzhi", [a(2)], [a(1)]]],
                ["$bzhi", ["&", [a(0)], [a(2)]], [a(1)]],
                true, "bzhi right-distributes over or", ,
            ],
            // other bzhi properties
            [
                ["&", ["$bzhi", [a(0)], [a(1)]], ["$bzhi", [a(0)], [a(2)]]],
                ["$bzhi", ["$bzhi", [a(0)], [a(1)]], [a(2)]],
                true, "combine bzhi", "split bzhi",
            ],
            // reversing a boolean has no effect
            [
                ["$reverse", ["==", [a(0)], [a(1)]]],
                ["==", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            [
                ["$reverse", ["!=", [a(0)], [a(1)]]],
                ["!=", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            [
                ["$reverse", ["<u", [a(0)], [a(1)]]],
                ["<u", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            [
                ["$reverse", ["<s", [a(0)], [a(1)]]],
                ["<s", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            [
                ["$reverse", ["<=u", [a(0)], [a(1)]]],
                ["<=u", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            [
                ["$reverse", ["<=s", [a(0)], [a(1)]]],
                ["<=s", [a(0)], [a(1)]],
                false, "reversing a boolean has no effect", ,
            ],
            // rotates
            [
                [">>>", [a(0)], [0]],
                [a(0)],
                false, "rotate by zero", ,
            ],
            [
                ["<<<", [a(0)], [0]],
                [a(0)],
                false, "rotate by zero", ,
            ],
            [
                [">>>", [a(0)], [a(1)]],
                ["|", [">>u", [a(0)], [a(1)]], ["<<", [a(0)], ["-", [a(1)]]]],
                true, "split ror into shifts", "combine shifts into ror",
            ],
            [
                ["<<<", [a(0)], [a(1)]],
                ["|", ["<<", [a(0)], [a(1)]], [">>u", [a(0)], ["-", [a(1)]]]],
                true, "split rol into shifts", "combine shifts into rol",
            ],
            // binomials
            [
                ["*", ["+", [a(0)], [a(1)]], ["+", [a(2)], [a(3)]]],
                ["+", ["*", [a(0)], [a(2)]], ["+", ["*", [a(0)], [a(3)]], ["+", ["*", [a(1)], [a(2)]], ["&", [a(1)], [a(3)]]]]],
                true, "work out product of binomials", "factor into binomials",
            ],
            [
                ["&", ["^", [a(0)], [a(1)]], ["^", [a(2)], [a(3)]]],
                ["^", ["&", [a(0)], [a(2)]], ["^", ["&", [a(0)], [a(3)]], ["^", ["&", [a(1)], [a(2)]], ["&", [a(1)], [a(3)]]]]],
                true, "work out product of binomials (GF(2))", "factor into binomials (GF(2))",
            ],
            [
                ["&", ["^", [a(0)], [a(1)]], ["^", [a(2)], [a(3)]]],
                ["^", ["^", ["^", ["&", [a(0)], [a(2)]], ["&", [a(0)], [a(3)]]], ["&", [a(1)], [a(2)]]], ["&", [a(1)], [a(3)]]],
                true, "work out product of binomials (GF(2))", "factor into binomials (GF(2))",
            ],
            // top bit addition
            [
                ["+", [a(0)], [0x80000000 | 0]],
                ["^", [a(0)], [0x80000000 | 0]],
                true, "carry out of the top bit is irrelevant", ,
            ],
            [
                ["-", [a(0)], [0x80000000 | 0]],
                ["^", [a(0)], [0x80000000 | 0]],
                true, "borrow out of the top bit is irrelevant", ,
            ],
            // hmul/division
            [
                [">>u", ["$hmul_u", [a(0)], [0xaaaaaaab | 0]], [1]],
                ["/u", [a(0)], [3]],
                false, "divide by hmul", ,
            ],
            [
                [">>u", ["$hmul_u", [a(0)], [0xcccccccd | 0]], [2]],
                ["/u", [a(0)], [5]],
                false, "divide by hmul", ,
            ],
            // (a & b) op (a | b)
            [
                ["+", ["&", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                ["+", [a(0)], [a(1)]],
                false, "bit-level commutativity of addition", ,
            ],
            [
                ["^", ["&", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                ["^", [a(0)], [a(1)]],
                false, "bit-level commutativity of xor", ,
            ],
            [
                ["|", ["&", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                ["|", [a(0)], [a(1)]],
                false, "bit-level commutativity of or", ,
            ],
            [
                ["&", ["&", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                ["&", [a(0)], [a(1)]],
                false, "bit-level commutativity of and", ,
            ],
            [
                ["-", ["+", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]],
                ["&", [a(0)], [a(1)]],
                false, "bit-level commutativity of addition", , "extra steps", [["-", ["+", ["&", [a(0)], [a(1)]], ["|", [a(0)], [a(1)]]], ["|", [a(0)], [a(1)]]]]
            ],
            // two's complement relations
            [
                ["-", [a(0)]],
                ["+", ["~", [a(0)]], [1]],
                true, "definition of two's complement", ,
            ],
            [
                ["-", [a(0)]],
                ["~", ["-", [a(0)], [1]]],
                true, "definition of two's complement", ,
            ],
            // relate signed and unsigned comparison
            [
                ["<u", [a(0)], [a(1)]],
                ["<s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                ["<s", [a(0)], [a(1)]],
                ["<u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                ["<=u", [a(0)], [a(1)]],
                ["<=s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                ["<=s", [a(0)], [a(1)]],
                ["<=u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                [">u", [a(0)], [a(1)]],
                [">s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                [">s", [a(0)], [a(1)]],
                [">u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                [">=u", [a(0)], [a(1)]],
                [">=s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            [
                [">=s", [a(0)], [a(1)]],
                [">=u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]],
                true, "unsigned/signed comparison conversion", ,
            ],
            // relate signed and unsigned max and min
            [
                ["^", ["$min_u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]], [0x80000000]],
                ["$min_s", [a(0)], [a(1)]],
                false, "convert unsigned/signed ordering", ,
            ],
            [
                ["^", ["$max_u", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]], [0x80000000]],
                ["$max_s", [a(0)], [a(1)]],
                false, "convert unsigned/signed ordering", ,
            ],
            [
                ["^", ["$min_s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]], [0x80000000]],
                ["$min_u", [a(0)], [a(1)]],
                false, "convert unsigned/signed ordering", ,
            ],
            [
                ["^", ["$max_s", ["^", [a(0)], [0x80000000]], ["^", [a(1)], [0x80000000]]], [0x80000000]],
                ["$max_u", [a(0)], [a(1)]],
                false, "convert unsigned/signed ordering", ,
            ],
            [
                ["~", ["$min_u", [a(0)], [a(1)]]],
                ["$max_u", ["~", [a(0)]], ["~", [a(1)]]],
                true, "complemented minimum is maximum of complements", "maximum of complements is complemented minimum",
            ],
            [
                ["~", ["$min_s", [a(0)], [a(1)]]],
                ["$max_s", ["~", [a(0)]], ["~", [a(1)]]],
                true, "complemented minimum is maximum of complements", "maximum of complements is complemented minimum",
            ],
            [
                ["~", ["$max_u", [a(0)], [a(1)]]],
                ["$min_u", ["~", [a(0)]], ["~", [a(1)]]],
                true, "complemented maximum is minimum of complements", "minimum of complements is complemented maximum",
            ],
            [
                ["~", ["$max_s", [a(0)], [a(1)]]],
                ["$min_s", ["~", [a(0)]], ["~", [a(1)]]],
                true, "complemented maximum is minimum of complements", "minimum of complements is complemented maximum",
            ],
            // add/sub
            [
                ["+", [a(0)], ["-", [a(1)]]],
                ["-", [a(0)], [a(1)]],
                true, "adding a negative", ,
            ],
            [
                ["+", ["-", [a(0)], [a(1)]], [a(1)]],
                [a(0)],
                false, "adding and subtracting the same thing cancels", ,
            ],
            [
                ["+", [a(0)], ["-", [a(1)], [a(2)]]],
                ["-", ["+", [a(0)], [a(1)]], [a(2)]],
                true, "associativity of addition", ,
            ],
            [
                ["+", ["-", [a(0)], [a(1)]], [a(2)]],
                ["-", ["+", [a(0)], [a(2)]], [a(1)]],
                false, "commutativity of addition", ,
            ],
            [
                ["-", ["+", [a(0)], [a(1)]], [a(1)]],
                [a(0)],
                false, "adding and subtracting the same thing cancels", ,
            ],
            [
                ["-", [a(0)], ["-", [a(0)], [a(1)]]],
                [a(1)],
                false, "adding and subtracting the same thing cancels", ,
            ],
            [
                ["~", ["+", ["~", [a(0)]], [a(1)]]],
                ["-", [a(0)], [a(1)]],
                false, "definition of subtraction", ,
            ],
            // pext/pdep
            [
                ["$pdep", ["$pext", [a(0)], [a(1)]], [a(1)]],
                ["&", [a(0)], [a(1)]],
                false, "selected bits are put back in their original positions", ,
            ],
            [
                ["$pext", ["$pext", [a(0)], [a(1)]], [a(2)]],
                ["$pext", [a(0)], ["$pdep", [a(2)], [a(1)]]],
                false, "merge extracts by composing the masks", ,
            ],
            [
                ["$pext", [a(0)], ["$pdep", [a(1)], [a(2)]]],
                ["$pext", ["$pext", [a(0)], [a(2)]], [a(1)]],
                false, "split extraction into two steps", ,
            ],
            [
                ["$pext", ["$pdep", [a(0)], [a(1)]], [a(1)]],
                ["&", [a(0)], ["$pext", [a(1)], [a(1)]]],
                false, "pseudoinverse of pdep", ,
            ],
            // special
            [
                ["&", [a(0)], ["~", [a(1)]]],
                ["^", ["&", [a(0)], [a(1)]], [a(0)]],
                false, "and with -1", , "extra steps", [["&", [a(0)], ["^", [a(1)], [-1]]], ["^", ["&", [a(0)], [a(1)]], ["&", [a(0)], [-1]]]]
            ],
            [
                ["-", ["+", [a(0)], [a(1)]], ["^", [a(0)], [a(1)]]],
                ["<<", ["&", [a(0)], [a(1)]], [1]],
                false, "", , "extra steps", [["-", ["+", ["<<", ["&", [a(0)], [a(1)]], [1]], ["^", [a(0)], [a(1)]]], ["^", [a(0)], [a(1)]]]]
            ],
            [
                ["-", ["+", [a(0)], [a(1)]], ["<<", ["&", [a(0)], [a(1)]], [1]]],
                ["^", [a(0)], [a(1)]],
                false, "", , "extra steps", [["-", ["+", ["<<", ["&", [a(0)], [a(1)]], [1]], ["^", [a(0)], [a(1)]]], ["<<", ["&", [a(0)], [a(1)]], [1]]], ["-", ["+", ["^", [a(0)], [a(1)]], ["<<", ["&", [a(0)], [a(1)]], [1]]], ["<<", ["&", [a(0)], [a(1)]], [1]]]]
            ],
            [
                ["+", ["$subus", [a(0)], [a(1)]], [a(1)]],
                ["$max_u", [a(0)], [a(1)]],
                false, "", , "extra steps", [["+", ["?", [">u", [a(0)], [a(1)]], ["-", [a(0)], [a(1)]], [0]], [a(1)]],
                    ["?", [">u", [a(0)], [a(1)]], ["+", ["-", [a(0)], [a(1)]], [a(1)]], ["+", [0], [a(1)]]],
                    ["?", [">u", [a(0)], [a(1)]], ["+", ["-", [a(0)], [a(1)]], [a(1)]], [a(1)]],
                    ["?", [">u", [a(0)], [a(1)]], [a(0)], [a(1)]]]
            ],
            [
                ["-", [a(0)], ["$subus", [a(0)], [a(1)]]],
                ["$min_u", [a(0)], [a(1)]],
                false, "", , "extra steps", [["-", [a(0)], ["?", [">u", [a(0)], [a(1)]], ["-", [a(0)], [a(1)]], [0]]],
                    ["?", [">u", [a(0)], [a(1)]], ["-", [a(0)], ["-", [a(0)], [a(1)]]], ["-", [a(0)], [0]]],
                    ["?", [">u", [a(0)], [a(1)]], ["-", [a(0)], ["-", [a(0)], [a(1)]]], [a(0)]],
                    ["?", [">u", [a(0)], [a(1)]], [a(1)], [a(0)]]]
            ]
        ];
        function convOps(root) {
            if (root.length == 1)
                return root;
            if (root.length == 2) {
                root[0] = unops.indexOf(root[0]);
                root[1] = convOps(root[1]);
                return root;
            }
            if (root[0] == "?")
                root[0] = 666;
            else
                root[0] = ops.indexOf(root[0]);
            for (var i = 1; i < root.length; i++)
                root[i] = convOps(root[i]);
            return root;
        }
        for (var i = 0; i < rules.length; i++) {
            rules[i][0] = convOps(rules[i][0]);
            rules[i][1] = convOps(rules[i][1]);
            if (!rules[i][4])
                rules[i][4] = rules[i][3];
            if (rules[i][5] == undefined)
                rules[i][5] = null;
            if (rules[i][6] == undefined)
                rules[i][6] = null;
            else {
                for (var j = 0; j < rules[i][6].length; j++)
                    rules[i][6][j] = convOps(rules[i][6][j]);
            }
        }
        function rev_rule(rule) {
            return [rule[1], rule[0], false, rule[4], rule[3], rule[5], rule[6], rule[7]];
        }
        function commute_rule(rule) {
            var c0 = rule[0];
            if (c0.length == 3)
                c0 = [c0[0], c0[2], c0[1]];
            var c1 = rule[1];
            if (c1.length == 3)
                c1 = [c1[0], c1[2], c1[1]];
            var s = rule.slice();
            s[0] = c0;
            s[1] = c1;
            return s;
        }
        var numrules = rules.length;
        for (var i = 0; i < numrules; i++) {
            if (rules[i][2]) {
                rules.push(rev_rule(rules[i]));
            }
        }
        this.oldrules = rules;
        this.Rules = new Array(0x8000);
        for (var i = 0; i < 0x8000; i++)
            this.Rules[i] = [];
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var from = rule[0];
            if (from.length == 1) {
                if (from[0].any != undefined) {
                    for (var p = 0; p < 0x8000; p++)
                        this.Rules[p].push(rule);
                }
                else {
                    // constant
                    debugger;
                    alert("rewrite rule starting with a constant");
                }
            }
            else if (from.length == 2) {
                // unary
                if (from[1][0].any != undefined) {
                    var bottom = (from[0] + 1) & 31;
                    for (var p = bottom; p < 0x8000; p += 32)
                        this.Rules[p].push(rule);
                }
                else if (from[1].length == 1) {
                    // unary of constant
                    debugger;
                    alert("rule has Unary(constant)");
                }
                else if (from[1].length == 2) {
                    // nested unary
                    this.Rules[(from[0] + 1 & 31) + ((from[1][0] + 1 & 31) << 5)].push(rule);
                }
                else if (from[1].length == 3) {
                    // unary with binary as operand
                    this.Rules[(from[0] + 1 & 31) + ((from[1][0] + 5 & 31) << 5)].push(rule);
                }
                else if (from[1].length == 4) {
                    // ternary as operand
                    var bottom = (from[0] + 1) & 31;
                    for (var p = bottom; p < 0x8000; p += 32)
                        this.Rules[p].push(rule);
                }
                else {
                    debugger;
                    alert("rule is badly formatted");
                }
            }
            else if (from.length == 3) {
                var bits = from[0] + 5 & 31;
                var mask = 0x01F;
                for (var j = 0; j < 2; j++) {
                    switch (from[j + 1].length) {
                        case 1:
                            if (from[j + 1][0].any == undefined) {
                                bits |= ((from[j + 1] & 15) | ((from[j + 1] >>> 31) << 4)) << (5 + 5 * j);
                                mask |= 0x3E0 << (5 * j);
                            }
                            break;
                        case 2:
                            bits |= (from[j + 1][0] + 1 & 31) << (5 + 5 * j);
                            mask |= 0x3E0 << (5 * j);
                            break;
                        case 3:
                            bits |= (from[j + 1][0] + 5 & 31) << (5 + 5 * j);
                            mask |= 0x3E0 << (5 * j);
                            break;
                        case 4:
                            break;
                        default:
                            debugger;
                            alert("rule is badly formatted");
                            break;
                    }
                }
                var had = new Int32Array(0x8000 >> 5);
                for (var p = 0; p < 0x8000; p = (p | mask) + 1 & ~mask) {
                    var idx = p | bits;
                    this.Rules[idx].push(rule);
                    had[idx >> 5] |= 1 << idx;
                }
                if (commutative[from[0]]) {
                    var mask2 = (mask & 0x1F) | ((mask & 0x3E0) << 5) | ((mask >> 5) & 0x3E0);
                    var bits2 = (bits & 0x1F) | ((bits & 0x3E0) << 5) | ((bits >> 5) & 0x3E0);
                    var commrule = commute_rule(rule);
                    for (var p = 0; p < 0x8000; p = (p | mask2) + 1 & ~mask2) {
                        var idx = p | bits2;
                        if ((had[idx >> 5] & (1 << idx)) == 0 && false)
                            this.Rules[idx].push(commrule);
                    }
                }
            }
            else if (from.length == 4) {
                var bits = 0x7000;
                var mask = 0x7000;
                for (var j = 0; j < 3; j++) {
                    switch (from[j + 1].length) {
                        case 1:
                            if (from[j + 1][0].any == undefined) {
                                bits |= (((from[j + 1] & 15) | ((from[j + 1] >>> 31) << 4)) << (4 * j)) & 0x15;
                                mask |= 0x00F << (4 * j);
                            }
                            break;
                        case 2:
                            bits |= (from[j + 1][0] + 1 & 15) << (4 * j);
                            mask |= 0x00F << (4 * j);
                            break;
                        case 3:
                            bits |= (from[j + 1][0] + 5 & 15) << (4 * j);
                            mask |= 0x00F << (4 * j);
                            break;
                        case 4:
                            break;
                        default:
                            debugger;
                            alert("rule is badly formatted");
                            break;
                    }
                }
                for (var p = 0; p < 0x8000; p = (p | mask) + 1 & ~mask) {
                    this.Rules[p | bits].push(rule);
                }
            }
        }
        var rulecount_hist = new Int32Array(64);
        for (var i = 0; i < this.Rules.length; i++)
            rulecount_hist[this.Rules[i].length]++;
        this.RulecountHist = rulecount_hist;
        return;
    }
    ProofFinder.prototype.Search = function (from, to, callback, debugcallback, mode, timelimit) {
        /* proof node format:
           [parent, expr, explanation, backwards, depth, pattern]
               0     1         2           3        4       5
         */
        if (this.dead)
            return;
        if (timelimit == undefined)
            timelimit = 99999999;
        var starttime = new Date();
        function hash_update(htable, key, val) {
            var h = (key.hash & 0x7fffffff) % 65521;
            if (htable[h] == undefined)
                htable[h] = [];
            var subtable = htable[h];
            for (var i = 0; i < subtable.length; i += 2) {
                if (key.equals2(subtable[i])) {
                    if (subtable[i + 1][4] > val[4]) {
                        subtable[i + 1] = val;
                        return true;
                    }
                    return false;
                }
            }
            subtable.push(key);
            subtable.push(val);
            return true;
        }
        function hash_get(htable, key) {
            var h = (key.hash & 0x7fffffff) % 65521;
            var subtable = htable[h];
            if (subtable == undefined)
                return null;
            for (var i = 0; i < subtable.length; i += 2) {
                if (key.equals2(subtable[i]))
                    return subtable[i + 1];
            }
            return null;
        }
        var complexity_weight = 2;
        var steps_weight = 3;
        function cmp(a, b) {
            var wa = a[1].weight * complexity_weight + a[4] * steps_weight;
            var wb = b[1].weight * complexity_weight + b[4] * steps_weight;
            if (wa < wb)
                return -1;
            if (wa > wb)
                return 1;
            return 0;
        }
        function heap_siftdown(heap, index) {
            "use strict";
            var child = (index << 1) + 1;
            while (child < heap.length) {
                var lowestChild = child;
                if (child + 1 < heap.length &&
                    cmp(heap[child], heap[child + 1]) > 0)
                    lowestChild = child + 1;
                if (cmp(heap[index], heap[lowestChild]) > 0) {
                    var temp = heap[lowestChild];
                    heap[lowestChild] = heap[index];
                    heap[index] = temp;
                    index = lowestChild;
                    child = (index << 1) + 1;
                }
                else
                    break;
            }
        }
        function heap_add(heap, item) {
            "use strict";
            var index = heap.length;
            heap.push(item);
            var parent = (index - 1) >>> 1;
            while (index != 0 && cmp(item, heap[parent]) < 0) {
                heap[index] = heap[parent];
                heap[parent] = item;
                index = parent;
                parent = (index - 1) >>> 1;
            }
        }
        function removeMin(heap) {
            "use strict";
            if (heap.length == 1) {
                return heap.pop();
            }
            var min = heap[0];
            heap[0] = heap.pop();
            var index = 0;
            heap_siftdown(heap, 0);
            return min;
        }
        function isTopLevelMatch(pattern, expr, wildcards, res_pattern) {
            var except_not = 1;
            var except_neg = 2;
            var except_zero = 3;
            var except_unknown_or_zero = 4;
            var except_non_mersenne = 5;
            if (pattern.length == 1) {
                if (pattern[0].any == undefined) {
                    // constant
                    if (expr.value == pattern[0]) {
                        if (res_pattern)
                            res_pattern[0] = expr;
                        return true;
                    }
                    return false;
                }
                else {
                    // any
                    var any_index = pattern[0].any;
                    if (wildcards[any_index] != undefined) {
                        if (expr.equals2(wildcards[any_index])) {
                            if (res_pattern) {
                                res_pattern[0] = new Variable(~any_index);
                                res_pattern[0].id = expr.id;
                            }
                            return true;
                        }
                        else
                            return false;
                    }
                    else {
                        if (pattern[0].except != undefined) {
                            switch (pattern[0].except) {
                                default: debugger;
                                case except_not:
                                    if (expr.type == 'un' && expr.op == 0)
                                        return false;
                                    break;
                                case except_neg:
                                    if (expr.type == 'un' && expr.op == 1)
                                        return false;
                                    break;
                                case except_zero:
                                    if (expr.type == 'const' && expr.value == 0)
                                        return false;
                                    break;
                                case except_unknown_or_zero:
                                    if (expr.type != 'const' || expr.value == 0)
                                        return false;
                                    break;
                                case except_non_mersenne:
                                    if (expr.type != 'const' || (expr.value & (expr.value + 1)) != 0 || expr.value == 0)
                                        return false;
                                    break;
                            }
                        }
                        wildcards[any_index] = expr;
                        if (res_pattern) {
                            res_pattern[0] = new Variable(~any_index);
                            res_pattern[0].id = expr.id;
                        }
                        return true;
                    }
                }
            }
            else if (pattern.length == 2) {
                var op = pattern[0];
                if (expr.type == 'const' && op < 2 && pattern[1].any != undefined && pattern[1].except == undefined) {
                    debugger;
                    var any_index = pattern[1].any;
                    var fake_expr = new Unary(op, new Constant(op == 0 ? ~expr.value : ~~-expr.value));
                    fake_expr.id = expr.id;
                    wildcards[any_index] = fake_expr;
                    if (res_pattern) {
                        res_pattern[0] = new Variable(~any_index);
                        res_pattern[0].id = expr.id;
                    }
                    return true;
                }
                if (expr.type != 'un' || op != expr.op)
                    return false;
                if (isTopLevelMatch(pattern[1], expr.value, wildcards, res_pattern)) {
                    if (res_pattern) {
                        res_pattern[0] = new Unary(expr.op, res_pattern[0]);
                        res_pattern[0].id = expr.id;
                    }
                    return true;
                }
                else
                    return false;
            }
            else if (pattern.length == 3) {
                if (expr.type != 'bin' || pattern[0] != expr.op)
                    return false;
                var r_res_pattern = res_pattern ? [null] : null;
                var backup = wildcards.slice();
                if (isTopLevelMatch(pattern[1], expr.l, wildcards, res_pattern) &&
                    isTopLevelMatch(pattern[2], expr.r, wildcards, r_res_pattern)) {
                    if (res_pattern) {
                        res_pattern[0] = new Binary(expr.op, res_pattern[0], r_res_pattern[0]);
                        res_pattern[0].id = expr.id;
                    }
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (pattern.length == 4) {
                if (expr.type == 'ter') {
                    var t_res_pattern = res_pattern ? [null] : null;
                    var f_res_pattern = res_pattern ? [null] : null;
                    if (isTopLevelMatch(pattern[1], expr.cond, wildcards, res_pattern) &&
                        isTopLevelMatch(pattern[2], expr.t, wildcards, t_res_pattern) &&
                        isTopLevelMatch(pattern[3], expr.f, wildcards, f_res_pattern)) {
                        if (res_pattern) {
                            res_pattern[0] = new Ternary(res_pattern[0], t_res_pattern[0], f_res_pattern[0]);
                            res_pattern[0].id = expr.id;
                        }
                        return true;
                    }
                    else
                        return false;
                }
                else if (expr.type == 'fun') {
                    if (pattern[0] != expr.fun)
                        return false;
                    return false;
                }
                else
                    return false;
            }
        }
        function rewrite(to, wildcards, rev, res_pattern) {
            if (to.length == 1) {
                if (to[0].any == undefined) {
                    // constant
                    var res = new Constant(to[0]);
                    if (res_pattern)
                        res_pattern[0] = res;
                    return res;
                }
                else {
                    // any
                    var any_index = to[0].any;
                    var cpy = wildcards[any_index].copy();
                    if (res_pattern) {
                        res_pattern[0] = new Variable(~any_index);
                        res_pattern[0].id = cpy.id;
                    }
                    return cpy;
                }
            }
            else if (to.length == 2) {
                var vr = rewrite(to[1], wildcards, rev, res_pattern);
                if (vr == null || (vr.type == 'un' && vr.op == to[0] &&
                    vr.value.type == 'un' && vr.value.op == to[0]))
                    return null;
                var res = new Unary(to[0], vr).constantFold(true);
                if (res_pattern) {
                    res_pattern[0] = new Unary(to[0], res_pattern[0]);
                    res_pattern[0].id = res.id;
                }
                return res;
            }
            else if (to.length == 3) {
                var lr = rewrite(to[1], wildcards, rev, res_pattern);
                if (lr == null)
                    return null;
                var r_res_pattern = res_pattern ? [null] : null;
                var rr = rewrite(to[2], wildcards, rev, r_res_pattern);
                if (rr == null)
                    return null;
                var res = new Binary(to[0], lr, rr).constantFold(true);
                if (res_pattern) {
                    res_pattern[0] = new Binary(to[0], res_pattern[0], r_res_pattern[0]);
                    res_pattern[0].id = res.id;
                }
                return res;
            }
            else if (to.length == 4) {
                var cr = rewrite(to[1], wildcards, rev, res_pattern);
                if (cr == null)
                    return null;
                var t_res_pattern = res_pattern ? [null] : null;
                var tr = rewrite(to[2], wildcards, rev, t_res_pattern);
                if (tr == null)
                    return null;
                var f_res_pattern = res_pattern ? [null] : null;
                var fr = rewrite(to[3], wildcards, rev, f_res_pattern);
                if (fr == null)
                    return null;
                var res = new Ternary(cr, tr, fr).constantFold(true);
                if (res_pattern) {
                    res_pattern[0] = new Ternary(res_pattern[0], t_res_pattern[0], f_res_pattern[0]);
                    res_pattern[0].id = res.id;
                }
                return res;
            }
            else
                debugger;
        }
        function match(rule, expr, res_pattern) {
            var wildcards = [];
            var rev = [];
            if (isTopLevelMatch(rule[0], expr, wildcards, res_pattern)) {
                var lhs = res_pattern ? res_pattern[0] : null;
                var res = rewrite(rule[1], wildcards, rev, res_pattern);
                if (res == null)
                    return null;
                res = res.constantFold();
                if (res_pattern)
                    res_pattern[0] = new Binary(20 /*ops.indexOf('==')*/, lhs, res_pattern[0]);
                return [res, wildcards, rev];
            }
            return null;
        }
        var opstr = [];
        opstr[1] = "and";
        opstr[2] = "or";
        opstr[3] = "xor";
        opstr[4] = "add";
        opstr[55] = "min";
        opstr[56] = "min";
        opstr[57] = "max";
        opstr[58] = "max";
        function applyRules(root, results, parent, backwards, allrules, getPattern) {
            "use strict";
            var patternNode = getPattern ? [null] : null;
            switch (root.type) {
                case 'const':
                    return;
                case 'var':
                    break;
                case 'un':
                    {
                        var startindex = results.length;
                        applyRules(root.value, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i] == null)
                                continue;
                            if (results[i][1].id != root.value.id &&
                                results[i][1].type == 'un' && results[i][1].op == root.op &&
                                results[i][1].value.type == 'un' && results[i][1].value.op == root.op)
                                results[i] = null;
                            else
                                results[i][1] = new Unary(root.op, results[i][1]);
                        }
                        break;
                    }
                case 'bin':
                    {
                        var startindex = results.length;
                        applyRules(root.l, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i])
                                results[i][1] = new Binary(root.op, results[i][1], root.r);
                        }
                        startindex = results.length;
                        applyRules(root.r, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i])
                                results[i][1] = new Binary(root.op, root.l, results[i][1]);
                        }
                        break;
                    }
                case 'ter':
                    {
                        var startindex = results.length;
                        applyRules(root.cond, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i])
                                results[i][1] = new Ternary(results[i][1], root.t, root.f);
                        }
                        startindex = results.length;
                        applyRules(root.t, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i])
                                results[i][1] = new Ternary(root.cond, results[i][1], root.f);
                        }
                        startindex = results.length;
                        applyRules(root.f, results, parent, backwards, allrules, getPattern);
                        for (var i = startindex; i < results.length; i++) {
                            if (results[i])
                                results[i][1] = new Ternary(root.cond, root.t, results[i][1]);
                        }
                    }
                    break;
            }
            function checkMatches(root, rules, results, parent, backwards, getPattern, matchonly) {
                "use strict";
                for (var i = 0; i < rules.length; i++) {
                    var mres = match(rules[i], root, patternNode);
                    if (mres != null) {
                        if (matchonly)
                            return true;
                        var n = mres[0];
                        if (rules[i][5] == "extra steps") {
                            if (getPattern) {
                                // don't generate pattern in 1 step
                                continue;
                            }
                            else {
                                var prev = parent;
                                for (var j = 0; j < rules[i][6].length; j++) {
                                    var expr = rewrite(rules[i][6][j], mres[1], mres[2], null);
                                    var node = [prev, expr, null, backwards, parent[4] + 6 + j, null];
                                    prev = node;
                                    results.push(node);
                                }
                                results.push([prev, n, rules[i], backwards, parent[4] + 1, null]);
                            }
                        }
                        else {
                            if (getPattern)
                                results.push([patternNode[0], n, rules[i]]);
                            else
                                results.push([parent, n, rules[i], backwards, parent[4] + 1, null]);
                        }
                    }
                }
                return false;
            }
            checkMatches(root, allrules[root.hash2], results, parent, backwards, getPattern, false);
            function mkvar(idx, id) {
                var v = new Variable(~idx);
                v.id = id;
                return v;
            }
            if (root.type == 'bin') {
                if (associative[root.op] &&
                    commutative[root.op]) {
                    var op = root.op;
                    var args = [];
                    function gatherArgs(root, args, op) {
                        if (root.type == 'bin' && root.op == op) {
                            gatherArgs(root.l, args, op);
                            gatherArgs(root.r, args, op);
                        }
                        else
                            args.push(root);
                    }
                    function rebuildTreeLike(root, argcb, op1, op2, idx) {
                        if (!idx)
                            idx = { argindex: 1 };
                        var l = null, r = null;
                        if (root.l.type == 'bin' && (root.l.op == op1 || root.l.op == op2))
                            l = rebuildTreeLike(root.l, argcb, op1, op2, idx);
                        else {
                            l = argcb(root.l, idx);
                            l.id = root.l.id;
                        }
                        if (root.r.type == 'bin' && (root.r.op == op1 || root.r.op == op2))
                            r = rebuildTreeLike(root.r, argcb, op1, op2, idx);
                        else {
                            r = argcb(root.r, idx);
                            r.id = root.r.id;
                        }
                        var res = new Binary(root.op, l, r);
                        res.id = root.id;
                        return res;
                    }
                    gatherArgs(root, args, op);
                    // TODO: look-ahead for matches on re-associated expr
                    if (args.length > 2) {
                        for (var j = 1; j < args.length; j++) {
                            for (var i = 0; i < j; i++) {
                                //var vroot = new Binary(op, args[i], args[j]);
                                //var hasMatch = checkMatches(vroot, allrules[vroot.hash2], [], null, backwards, getPattern, true);
                            }
                        }
                    }
                    if (op == 2 || op == 3 || op == 4) {
                        // |, ^, +
                        // look for non-intersecting bits
                        function noIntersect(l, r) {
                            if (l.type == 'bin' && l.op == 1 /* & */ &&
                                r.type == 'bin' && r.op == 1 /* & */) {
                                var ll = l.l;
                                var lr = l.r;
                                var rl = r.l;
                                var rr = r.r;
                                function test(node, l, r) {
                                    if (node.type == 'const' && l.type == 'const' && (l.value & node.value) == 0)
                                        return true;
                                    if (node.type == 'const' && r.type == 'const' && (r.value & node.value) == 0)
                                        return true;
                                    if (node.type == 'un' && node.op == 0)
                                        return node.value.equals(l) || node.value.equals(r);
                                    return false;
                                }
                                var r = test(ll, rl, rr) ||
                                    test(lr, rl, rr) ||
                                    test(rl, ll, lr) ||
                                    test(rr, ll, lr);
                                return r;
                            }
                        }
                        var L = root.l;
                        var R = root.r;
                        if (noIntersect(L, R)) {
                            var ops = [2, 3, 4];
                            ops.splice(ops.indexOf(op), 1);
                            for (var i = 0; i < ops.length; i++) {
                                var newOp = ops[i];
                                var res = new Binary(newOp, L, R);
                                if (getPattern) {
                                    var pp = new Binary(op, mkvar(0, L.id), mkvar(1, R.id));
                                    pp.id = root.id;
                                    var rp = new Binary(newOp, mkvar(0, L.id), mkvar(1, R.id));
                                    rp.id = res.id;
                                    var p = new Binary(20, pp, rp);
                                    var descF = opstr[op] + " is " + opstr[newOp] + " when bits <a class='replace'>don't intersect</a>";
                                    var descR = opstr[newOp] + " is " + opstr[op] + " when bits <a class='replace'>don't intersect</a>";
                                    results.push([p, res, [, , , descF, descR], new Binary(20, new Binary(1, root.l, root.r), new Constant(0))]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 2, null]);
                            }
                        }
                    }
                    switch (op) {
                        default: break;
                        case 3:
                            // xor
                            // try to turn xors of shifted values into clmul
                            var unshifted = args.find(function (a) { return a.type != "bin" || a.op != 6; });
                            if (unshifted && args.every(function (a) {
                                return (a.id == unshifted.id && a.equals2(unshifted)) ||
                                    (a.type == "bin" && a.op == 6 &&
                                        a.r.type == "const" && a.l.equals2(unshifted));
                            })) {
                                var M = 0;
                                for (var i = 0; i < args.length; i++) {
                                    var a = args[i];
                                    if (a.id == unshifted.id)
                                        M = M + 1 | 0;
                                    else
                                        M = M + (1 << a.r.value) | 0;
                                }
                                var res = new Binary(61, unshifted, new Constant(M));
                                if (getPattern) {
                                    var rp = new Binary(61, mkvar(0, unshifted.id), res.r);
                                    rp.id = res.id;
                                    var pp = rebuildTreeLike(root, function (e, a) {
                                        if (e.equals2(unshifted))
                                            return mkvar(0, 0);
                                        else
                                            return new Binary(6, mkvar(0, e.l.id), e.r);
                                    }, op, -1);
                                    var p = new Binary(20, pp, rp);
                                    results.push([p, res, [, , , "combine xors into clmul", "split clmul into xors"]]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
                            }
                            break;
                        case 4:
                            // addition
                            // try to turn additions of shifted values into multiply
                            var unshifted = args.find(function (a) { return a.type != "bin" || a.op != 6; });
                            if (unshifted && args.every(function (a) {
                                return (a.id == unshifted.id && a.equals2(unshifted)) ||
                                    (a.type == "bin" && a.op == 6 &&
                                        a.r.type == "const" && a.l.equals2(unshifted));
                            })) {
                                var M = 0;
                                for (var i = 0; i < args.length; i++) {
                                    var a = args[i];
                                    if (a.id == unshifted.id && a.equals2(unshifted))
                                        M = M + 1 | 0;
                                    else
                                        M = M + (1 << a.r.value) | 0;
                                }
                                var res = new Binary(11, unshifted, new Constant(M));
                                if (getPattern) {
                                    var rp = new Binary(11, mkvar(0, unshifted.id), res.r);
                                    rp.id = res.id;
                                    var pp = rebuildTreeLike(root, function (e, a) {
                                        if (e.equals2(unshifted))
                                            return mkvar(0, 0);
                                        else
                                            return new Binary(6, mkvar(0, e.l.id), e.r);
                                    }, op, -1);
                                    var p = new Binary(20, pp, rp);
                                    results.push([p, res, [, , , "combine additions into multiplication", "split multiplication into additions"]]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
                            }
                            // check complementary subsets
                            if (args.some(function (e) { return e.type != 'bin' || e.op != 1 || (e.l.type != 'const' && e.r.type != 'const'); }))
                                break;
                            var values = args.map(function (e) { return e.l.type == 'const' ? e.l.value : e.r.value; });
                            var isgood = true;
                            for (var i = 1; i < values.length; i++)
                                for (var j = 0; j < i; j++)
                                    if ((values[i] & values[j]) != 0)
                                        isgood = false;
                            if (!isgood)
                                break;
                            if (values.reduce(function (a, b) { return a | b; }, 0) != -1)
                                break;
                            var res = args[0].l.type == 'const' ? args[0].r : args[0].l;
                            if (args.some(function (e) { return !res.equals2(e.l) && !res.equals2(e.r); }))
                                break;
                            if (getPattern) {
                                var pp = rebuildTreeLike(root, function (e, a) { return e.equals2(res) ? mkvar(0, 0) : mkvar(a.argindex++, 0); }, op, 1);
                                var p = new Binary(20, pp, mkvar(0, res.id));
                                var desc = "addition of complementary subsets (condition: masks exactly cover -1)";
                                results.push([p, res, [, , , desc, desc]]);
                            }
                            else
                                results.push([parent, res, null, backwards, parent[4] + 1, null]);
                    }
                }
                else if (root.op == 6 || root.op == 30 || root.op == 31) {
                    var op = root.op;
                    var args = [];
                    function gatherArgs(root, args, op) {
                        if (root.type == 'bin' && root.op == op) {
                            gatherArgs(root.l, args, op);
                            args.push(root.r);
                        }
                        else
                            args.push(root);
                    }
                    gatherArgs(root, args, op);
                    if (args.length > 2) {
                        // chained shifts
                        var base = args[0];
                        args = args.slice(1);
                        if (args.every(function (a) { return a.type == 'const'; })) {
                            var total = args.reduce(function (a, b) { return a + (b.value & 31) | 0; }, 0);
                            if ((total >>> 0) >= 32 && op == 30) {
                                var res = new Binary(30, base, new Constant(31));
                                if (getPattern) {
                                    var p = new Binary(20, root, res);
                                    var desc = "shifting (arithmetic) by 32 or more in total";
                                    results.push([p, res, [, , , desc, desc]]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
                            }
                            else if ((total >>> 0) >= 32 && op != 30) {
                                var res = new Constant(0);
                                if (getPattern) {
                                    var p = new Binary(20, root, res);
                                    var desc = "shifting (logical) by 32 or more in total";
                                    results.push([p, res, [, , , desc, desc]]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
                            }
                            else {
                                var res = new Binary(op, base, new Constant(total));
                                if (getPattern) {
                                    var p = new Binary(20, root, res);
                                    var fdesc = "chained shifts can be combined if total shift amount is &lt;u 32";
                                    var rdesc = "shift can be decomposed into several steps";
                                    results.push([p, res, [, , , fdesc, rdesc]]);
                                }
                                else
                                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
                            }
                        }
                    }
                }
                else if (root.op == 33) {
                    // /u
                    if (root.r.type == 'const' && popcnt(root.r.value) == 1) {
                        var res = new Binary(31, root.l, new Constant(ctz(root.r.value)));
                        if (getPattern) {
                            var sh = new Unary(3, mkvar(1, root.r.id));
                            sh.id = res.r.id;
                            var p = new Binary(20, new Binary(33, mkvar(0, root.l.id), mkvar(1, root.r.id)), new Binary(31, mkvar(0, root.l.id), sh));
                            p.l.id = root.id;
                            p.r.id = res.id;
                            var desc = "division by power of two (condition: y is a power of two)";
                            results.push([p, res, [, , , desc, desc]]);
                        }
                        else
                            results.push([parent, res, null, backwards, parent[4] + 1, null]);
                    }
                }
                else if (root.op == 35) {
                    // %u
                    if (root.r.type == 'const' && popcnt(root.r.value) == 1) {
                        var res = new Binary(1, root.l, new Constant(~~(root.r.value - 1)));
                        if (getPattern) {
                            var msk = new Binary(5, mkvar(1, root.r.id), new Constant(1));
                            msk.id = res.r.id;
                            var p = new Binary(20, new Binary(35, mkvar(0, root.l.id), mkvar(1, root.r.id)), new Binary(1, mkvar(0, root.l.id), msk));
                            p.l.id = root.id;
                            p.r.id = res.id;
                            var desc = "remainder by power of two (condition: y is a power of two)";
                            results.push([p, res, [, , , desc, desc]]);
                        }
                        else
                            results.push([parent, res, null, backwards, parent[4] + 1, null]);
                    }
                }
                else if (root.op == 12) {
                    // /e
                    if (root.r.type == 'const' && popcnt(root.r.value) == 1) {
                        var res = new Binary(30, root.l, new Constant(ctz(root.r.value)));
                        if (getPattern) {
                            var sh = new Unary(3, mkvar(1, root.r.id));
                            sh.id = res.r.id;
                            var p = new Binary(20, new Binary(12, mkvar(0, root.l.id), mkvar(1, root.r.id)), new Binary(30, mkvar(0, root.l.id), sh));
                            p.l.id = root.id;
                            p.r.id = res.id;
                            var desc = "division by power of two (condition: y is a power of two)";
                            results.push([p, res, [, , , desc, desc]]);
                        }
                        else
                            results.push([parent, res, null, backwards, parent[4] + 1, null]);
                    }
                }
                else if (root.op == 13) {
                    // %e
                    if (root.r.type == 'const' && popcnt(root.r.value) == 1) {
                        var res = new Binary(1, root.l, new Constant(~~(root.r.value - 1)));
                        if (getPattern) {
                            var msk = new Binary(5, mkvar(1, root.r.id), new Constant(1));
                            msk.id = res.r.id;
                            var p = new Binary(20, new Binary(13, mkvar(0, root.l.id), mkvar(1, root.r.id)), new Binary(1, mkvar(0, root.l.id), msk));
                            p.l.id = root.id;
                            p.r.id = res.id;
                            var desc = "remainder by power of two (condition: y is a power of two)";
                            results.push([p, res, [, , , desc, desc]]);
                        }
                        else
                            results.push([parent, res, null, backwards, parent[4] + 1, null]);
                    }
                }
                else if (root.op == 50) {
                    // pdep
                }
            }
            if (root.type == 'bin' && !mayThrow(root.op) && root.l.type == 'ter' &&
                root.l.cond.type == 'bin' && binOpResultsInBool(root.l.cond.op)) {
                var res = new Ternary(root.l.cond, new Binary(root.op, root.l.t, root.r), new Binary(root.op, root.l.f, root.r));
                if (getPattern) {
                    // (C ? X : Y) + Z
                    var C = mkvar(0, root.l.cond.id), X = mkvar(1, root.l.t.id), Y = mkvar(2, root.l.f.id), Z = mkvar(3, root.r.id);
                    var p = new Binary(20, new Binary(root.op, new Ternary(C, X, Y), Z), new Ternary(C, new Binary(root.op, X, Z), new Binary(root.op, Y, Z)));
                    p.l.id = root.id;
                    p.r.id = res.id;
                    p.l.l.id = root.l.id;
                    p.r.t.id = res.t.id;
                    p.r.f.id = res.f.id;
                    var desc = "anything distributes over conditional-select (condition: x is a boolean)";
                    results.push([p, res, [, , , desc, desc]]);
                }
                else
                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
            }
            if (root.type == 'bin' && !mayThrow(root.op) && root.r.type == 'ter' &&
                root.r.cond.type == 'bin' && binOpResultsInBool(root.r.cond.op)) {
                var res = new Ternary(root.r.cond, new Binary(root.op, root.l, root.r.t), new Binary(root.op, root.l, root.r.f));
                if (getPattern) {
                    // X + (C ? Y : Z)
                    var X = mkvar(1, root.l.id), C = mkvar(0, root.r.cond.id), Y = mkvar(2, root.r.t.id), Z = mkvar(3, root.r.f.id);
                    var p = new Binary(20, new Binary(root.op, X, new Ternary(C, Y, Z)), new Ternary(C, new Binary(root.op, X, Y), new Binary(root.op, X, Z)));
                    p.l.id = root.id;
                    p.r.id = res.id;
                    p.l.r.id = root.r.id;
                    p.r.t.id = res.t.id;
                    p.r.f.id = res.f.id;
                    var desc = "anything distributes over conditional-select (condition: x is a boolean)";
                    results.push([p, res, [, , , desc, desc]]);
                }
                else
                    results.push([parent, res, null, backwards, parent[4] + 1, null]);
            }
            if (root.type != 'const') {
                if (getPattern)
                    results.push([, root, [, , , "constant folding", "constant folding"]]);
                else
                    results.push([parent, root, null, backwards, parent[4] + 1, null]);
            }
        }
        function fixup_ids_search(a, b, pattern) {
            // some sub-expression of 'a' matches the pattern,
            // change the ids in the pattern to the corresponding ids in 'b'
            switch (a.type) {
                case 'const':
                case 'var':
                    if (a.id != pattern.id)
                        return false;
                    fixup_ids(a, b, pattern);
                    return true;
                case 'un':
                    if (a.id == pattern.id) {
                        fixup_ids(a, b, pattern);
                        return true;
                    }
                    else if (b.type == 'un' && b.op == a.op)
                        return fixup_ids_search(a.value, b.value, pattern);
                    else
                        return false;
                case 'bin':
                    if (a.id == pattern.id) {
                        fixup_ids(a, b, pattern);
                        return true;
                    }
                    else if (b.type == 'bin' && b.op == a.op)
                        return fixup_ids_search(a.l, b.l, pattern) ||
                            fixup_ids_search(a.r, b.r, pattern);
                    else
                        return false;
                case 'ter':
                    if (a.id == pattern.id) {
                        fixup_ids(a, b, pattern);
                        return true;
                    }
                    else if (b.type == 'ter')
                        return fixup_ids_search(a.cond, b.cond, pattern) ||
                            fixup_ids_search(a.t, b.t, pattern) ||
                            fixup_ids_search(a.f, b.f, pattern);
                    else
                        return false;
                case 'fun':
                    return false;
                default: debugger;
            }
        }
        function fixup_ids(a, b, pattern) {
            // a has the same ids as pattern
            // returns: nothing
            // modifies the pattern, with ids changed to match b
            // a and b must be the same expression
            switch (a.type) {
                case 'const':
                case 'var':
                    if (pattern.id == a.id)
                        pattern.id = b.id;
                    break;
                case 'un':
                    if (pattern.id == a.id) {
                        if (pattern.type == 'un')
                            fixup_ids(a.value, b.value, pattern.value);
                        else if (pattern.type != 'var')
                            debugger;
                        pattern.id = b.id;
                    }
                    else
                        fixup_ids(a.value, b.value, pattern);
                    break;
                case 'bin':
                    if (pattern.id == a.id) {
                        if (pattern.type == 'bin') {
                            fixup_ids(a.l, b.l, pattern.l);
                            fixup_ids(a.r, b.r, pattern.r);
                        }
                        else if (pattern.type != 'var')
                            debugger;
                        pattern.id = b.id;
                    }
                    else {
                        fixup_ids(a.l, b.l, pattern);
                        fixup_ids(a.r, b.r, pattern);
                    }
                    break;
                case 'ter':
                    if (pattern.id == a.id) {
                        if (pattern.type == 'ter') {
                            fixup_ids(a.cond, b.cond, pattern.cond);
                            fixup_ids(a.t, b.t, pattern.t);
                            fixup_ids(a.f, b.f, pattern.f);
                        }
                        else if (pattern.type != 'var')
                            debugger;
                        pattern.id = b.id;
                    }
                    else {
                        fixup_ids(a.cond, b.cond, pattern);
                        fixup_ids(a.t, b.t, pattern);
                        fixup_ids(a.f, b.f, pattern);
                    }
                    break;
                case 'fun':
                    break;
                default: debugger;
            }
        }
        function processNode(proofnode, backwards, htable, q, otherside, maxweight, rules) {
            var results = [];
            applyRules(proofnode[1], results, proofnode, backwards, rules, false);
            for (var i = 0; i < results.length; i++) {
                var p = results[i];
                if (p == null)
                    continue;
                /*if (proofnode[0]) {
                    var unc0 = proofnode[0][1].containsDoubleUnary();
                    var unc1 = proofnode[1].containsDoubleUnary();
                    if (unc1 > unc0) {
                        var unc2 = p[1].containsDoubleUnary();
                        if (unc2 >= unc1)
                            continue;
                    }
                }*/
                if (p[1].weight < maxweight && hash_update(htable, p[1], p)) {
                    heap_add(q, p);
                }
                var connection = hash_get(otherside, p[1]);
                if (connection != null) {
                    return [p[4] + connection[4], p, connection, backwards];
                }
            }
            return null;
        }
        function makesteps(backwards, p, connection, rules) {
            "use strict";
            var c = p;
            var steps = [];
            var proofsteps = [];
            if (!backwards) {
                while (c != null) {
                    if (c[3])
                        debugger;
                    steps.unshift(c[1]);
                    c = c[0];
                }
                steps[steps.length - 1] = connection[1];
                c = connection;
                while (c != null && c[0] != null) {
                    if (!c[3])
                        debugger;
                    steps.push(c[0][1]);
                    c = c[0];
                }
            }
            else {
                while (c != null && c[0] != null) {
                    if (!c[3])
                        debugger;
                    steps.push(c[0][1]);
                    c = c[0];
                }
                c = connection;
                while (c != null) {
                    if (c[3])
                        debugger;
                    steps.unshift(c[1]);
                    c = c[0];
                }
            }
            // find explanations
            for (var j = 0; j < steps.length - 1; j++) {
                var f = steps[j];
                var t = steps[j + 1];
                var explanation = null;
                var explbackwards = false;
                // try forwards
                var forwardSet = [];
                applyRules(f, forwardSet, [, , , , 0], false, rules, true);
                var possibleExplanations = [];
                for (var k = 0; k < forwardSet.length; k++) {
                    if (forwardSet[k] && t.equals2(forwardSet[k][1])) {
                        explanation = forwardSet[k];
                        if (explanation[2][5])
                            debugger;
                        if (explanation[0])
                            fixup_ids_search(explanation[1], t, explanation[0].r);
                        possibleExplanations.push(explanation);
                    }
                }
                //explanation = null;
                for (var k = 0; k < possibleExplanations.length; k++) {
                    explanation = possibleExplanations[k];
                    if (explanation[2][3] == "constant folding")
                        break;
                }
                // try backwards
                if (!explanation) {
                    var backwardSet = [];
                    applyRules(t, backwardSet, [, , , , 0], false, rules, true);
                    for (var k = 0; k < backwardSet.length; k++) {
                        if (backwardSet[k] && f.equals2(backwardSet[k][1])) {
                            explanation = backwardSet[k];
                            if (explanation[2][5])
                                debugger;
                            explbackwards = true;
                            if (explanation[0]) {
                                var patl = explanation[0].l;
                                var patr = explanation[0].r;
                                fixup_ids_search(explanation[1], f, patr);
                                explanation[0].l = patr;
                                explanation[0].r = patl;
                            }
                            break;
                        }
                    }
                }
                // output proof
                proofsteps.push(steps[j]);
                var explindex = explbackwards ? 4 : 3;
                if (explanation == null)
                    proofsteps.push([]);
                else
                    proofsteps.push([explanation[2][explindex], explanation[0], explanation[3]]);
            }
            proofsteps.push(steps[steps.length - 1]);
            return proofsteps;
        }
        if (to) {
            if (from.equals2(to)) {
                var v1 = new Variable(-1);
                v1.id = from.id;
                var v2 = new Variable(-1);
                v2.id = to.id;
                callback([from, ["structurally equal", new Binary(20, v1, v2)], to]);
                return;
            }
            var fromc = from.copy().constantFold();
            var toc = to.copy().constantFold();
            if (from.equals2(toc)) {
                var v1 = new Variable(-1);
                v1.id = from.id;
                var v2 = new Variable(-1);
                v2.id = toc.id;
                callback([from, ["constant folding", new Binary(20, v1, v2)], toc]);
                return;
            }
            if (fromc.equals2(to)) {
                var v1 = new Variable(-1);
                v1.id = from.id;
                var v2 = new Variable(-1);
                v2.id = to.id;
                callback([from, ["constant folding", new Binary(20, v1, v2)], to]);
                return;
            }
            from = fromc;
            to = toc;
            from.start = true;
            to.end = true;
            if (from.equals(to)) {
                var v1 = new Variable(-1);
                v1.id = from.id;
                var v2 = new Variable(-1);
                v2.id = to.id;
                callback([from, ["structurally equal after normalization", new Binary(20, v1, v2)], to]);
                return;
            }
        }
        else {
            from = from.constantFold();
            complexity_weight = 5;
            steps_weight = 1;
        }
        // priority queues
        var q1 = [];
        var q2 = [];
        // hash maps
        var h1 = [];
        var h2 = [];
        q1.push([null, from, null, false, 0, null]);
        if (to) {
            q2.push([null, to, null, true, 0, null]);
            hash_update(h2, to, q2[0]);
        }
        hash_update(h1, from, q1[0]);
        var w = [];
        var maxstep = 999999;
        function loop_async(index, q1, q2, h1, h2, from, to, rules, cb) {
            var maxForwardWeight = from.weight + 6;
            var maxBackwardWeight = to.weight + 6;
            var counter = 0;
            var found = false;
            var proofsteps = [];
            while (q1.length + q2.length > 0 && counter < 10 && (counter == 0 || mode !== 'slow')) {
                var time = new Date();
                if (time.getTime() - starttime.getTime() > Math.min(timelimit, 2000) && mode !== 'slow') {
                    cb(null);
                    return;
                }
                counter++;
                // forward step
                var doReset = false;
                if (q1.length > 0) {
                    var pn = removeMin(q1);
                    if (debugcallback)
                        debugcallback(pn[1], false, pn[0]);
                    var found = processNode(pn, false, h1, q1, h2, maxForwardWeight, rules);
                    if (found != null && found[0] < maxstep) {
                        doReset = w.length == 0;
                        w.push(found);
                        maxstep = found[0];
                    }
                }
                // backward step
                if (q2.length > 0 && !doReset) {
                    var pn = removeMin(q2);
                    if (debugcallback)
                        debugcallback(pn[1], true, pn[0]);
                    var found = processNode(pn, true, h2, q2, h1, maxBackwardWeight, rules);
                    if (found != null && found[0] < maxstep) {
                        doReset = w.length == 0;
                        w.push(found);
                        maxstep = found[0];
                    }
                }
                //
                if (doReset && mode !== 'slow') {
                    // used after the first proof is found
                    // search again from scratch with more focus on short proofs
                    complexity_weight = 0;
                    q1 = [];
                    q2 = [];
                    h1 = [];
                    h2 = [];
                    q1.push([null, from, null, false, 0, null]);
                    q2.push([null, to, null, true, 0, null]);
                    hash_update(h1, from, q1[0]);
                    hash_update(h2, to, q2[0]);
                }
            }
            if (w.length > 0 && (index > 10 || mode === 'slow')) {
                var witness = w.pop();
                proofsteps = makesteps(witness[3], witness[1], witness[2], rules);
                cb(proofsteps);
            }
            else if (index > 100 && mode !== 'slow' || index > 1000) {
                cb(null);
            }
            else if (mode === 'synchronous')
                loop_async(index + 1, q1, q2, h1, h2, from, to, rules, cb);
            else {
                setTimeout(function () {
                    loop_async(index + 1, q1, q2, h1, h2, from, to, rules, cb);
                }, mode === 'slow' ? 200 : 0);
            }
        }
        function loop_async_simp(index, best, q1, h1, from, rules, cb) {
            var maxForwardWeight = from.weight + 5;
            for (var counter = 0; counter < 10; counter++) {
                var time = new Date();
                if (q1.length == 0 || index > 100 || time.getTime() - starttime.getTime() > Math.min(timelimit, 2000)) {
                    if (best.n[1].equals(from)) {
                        cb(null, null);
                    }
                    else {
                        var node = best.n;
                        proofsteps = makesteps(false, node, [null, node[1]], rules);
                        cb(proofsteps, node[1]);
                    }
                    return;
                }
                // forward step only
                var pn = removeMin(q1);
                if (debugcallback)
                    debugcallback(pn[1], false, pn[0]);
                if (pn[1].weight < best.w) {
                    best.w = pn[1].weight;
                    best.n = pn;
                }
                // ignore result, no match can be found
                processNode(pn, false, h1, q1, [], maxForwardWeight, rules);
            }
            setTimeout(function () {
                loop_async_simp(index + 1, best, q1, h1, from, rules, cb);
            }, 0);
        }
        if (to)
            loop_async(0, q1, q2, h1, h2, from, to, this.Rules, callback);
        else
            loop_async_simp(0, { w: from.weight, n: q1[0] }, q1, h1, from, this.Rules, callback);
        return;
    };
    ProofFinder.proveAsync = function (from, to, cb, debugcb) {
        var pf = new ProofFinder(20);
        pf.Search(from, to, function (steps, res) {
            cb(steps, res);
        }, debugcb, 2000);
    };
    // END - prooffinder
    return { ProofFinder: ProofFinder, Binary: Binary, Variable: Variable };
})();

"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a = exports, ProofFinder = _a.ProofFinder, Binary = _a.Binary, Variable = _a.Variable;
function isGroup(input) {
    if (input === null || typeof input != 'object') {
        return false;
    }
    return typeof input['op'] === 'string' &&
        Array.isArray(input['items']);
}
function isTerm(input) {
    if (input === null || typeof input != 'object') {
        return false;
    }
    return typeof input['selector'] === 'string' &&
        typeof input['op'] === 'string' &&
        typeof input['match'] === 'string';
}
function matchTerms(target, example) {
    return target.selector === example.selector &&
        target.op === example.op &&
        target.match === example.match;
}
function matchGroup(target, example) {
    var e_1, _a;
    if (target.op !== example.op) {
        return false;
    }
    if (target.items.length !== example.items.length) {
        return false;
    }
    var _loop_1 = function (item) {
        // console.log('look for', item, ' in ', example.items);
        var found = example.items.find(function (exampleItem) { return matches(item, exampleItem); });
        if (found === undefined) {
            return { value: false };
        }
        console.log(item, 'matched', found);
    };
    try {
        for (var _b = __values(target.items), _c = _b.next(); !_c.done; _c = _b.next()) {
            var item = _c.value;
            var state_1 = _loop_1(item);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
function matches(target, example) {
    if (isTerm(target)) {
        if (isTerm(example)) {
            return matchTerms(target, example);
        }
        else {
            return false;
        }
    }
    if (isGroup(example)) {
        return matchGroup(target, example);
    }
    return false;
}
function textMatches(parse, target, example) {
    // Failing to parse the target is an error, since that's user-supplied
    var targetParsed = parse(target);
    var vars = {};
    var targetHarold = toHarold(targetParsed, vars);
    try {
        var exampleParsed = parse(example);
        var exampleHarold = toHarold(exampleParsed, vars);
        // return matches(targetParsed, exampleParsed);
        return haroldsMatch(targetHarold, exampleHarold, vars);
    }
    catch (e) {
        return false;
    }
}
var harold_ops = [, "&", "|", "^", "+", "-", "<<", ">>", "<<<", ">>>", "/", "*", "/e", "%e", "/p", , , , , , "==", "!=", "<=", "<", ">=", ">", "=>", "&&", "||", , ">>s", ">>u", "/s", "/u", "%s", "%u", , , , , "<=s", "<=u", "<s", "<u", ">=s", ">=u", ">s", ">u", "$bzhi", "$subus", "$pdep", "$pext", "$avg_up", "$addus", , "$min_u", "$min_s", "$max_u", "$max_s", "$hmul_u", "$hmul_s", "$clmul", "$clpow", "$ormul"];
var OPS = {
    '&&': harold_ops.indexOf('&&'),
    '||': harold_ops.indexOf('||'),
    '==': harold_ops.indexOf('==')
};
function toHarold(root, vars) {
    var matchedVars = true;
    var existingKeys = new Set(Object.keys(vars));
    function findTerm(term) {
        var key = [term.selector, term.op, term.match].join('%');
        if (key in vars) {
            existingKeys.delete(key);
            return vars[key];
        }
        else {
            var index = Object.entries(vars).length;
            vars[key] = index;
            matchedVars = false;
            return index;
        }
    }
    function nodeToHarold(input) {
        if (isTerm(input)) {
            var termIndex = findTerm(input);
            return new Variable(termIndex);
        }
        else {
            var l = nodeToHarold(input.l);
            var r = nodeToHarold(input.r);
            var op = OPS[input.op];
            return new Binary(op, l, r);
        }
    }
    var expr = nodeToHarold(root);
    if (existingKeys.size > 0) {
        matchedVars = false;
    }
    return { matchedVars: matchedVars, expr: expr };
}
function haroldsMatch(target, example, varMap) {
    var e_2, _a;
    if (example.matchedVars === false) {
        return false;
    }
    var pf = new ProofFinder(OPS['==']);
    var proof = null;
    pf.Search(target.expr.removeDummy(), example.expr.removeDummy(), function (steps) {
        proof = steps;
    }, function (err, backwards) {
    }, "synchronous", 400);
    // console.log('proof', proof);
    if (proof !== null) {
        return true;
    }
    // Didn't find a proof, try backup method
    var root = new Binary(OPS['=='], target.expr, example.expr);
    var bddf = root.toBddFunc();
    var varEntries = Object.entries(varMap);
    var varArray = new Array(varEntries.length);
    try {
        for (var varEntries_1 = __values(varEntries), varEntries_1_1 = varEntries_1.next(); !varEntries_1_1.done; varEntries_1_1 = varEntries_1.next()) {
            var _b = __read(varEntries_1_1.value, 2), key = _b[0], index = _b[1];
            varArray[index] = key;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (varEntries_1_1 && !varEntries_1_1.done && (_a = varEntries_1.return)) _a.call(varEntries_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var data = {
        varmap: varArray,
        quantified: [],
        simp: bddf.Identify(varArray),
        properties: {}
    };
    // console.log(JSON.stringify(data, null, 2));
    var result = bddf.AnalyzeTruth(data, root, varArray, function (result) {
        // console.log('got a result', result);
    }, null);
    // console.log('returned result', result);
    return ('true' in result) && result.true.count === '#always';
}
return textMatches(this.peg.parse, target, example);
$$ language plv8;

-- migrate:down
DROP FUNCTION aws_logs_metricfilter_pattern_matches;